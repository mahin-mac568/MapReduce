A Framework
Robbert

for Protocol

Composition

van Renesse, Kenneth P. Birman, Roy Friedman,
Mark Hayden, and David A. Karr
Dept.

of Computer

Cornell

University

The Horus system supports
a communication
architecture
that treats protocols
as instances of an abstract
data type.
This approach
encourages
developers
to partition
complex
protocols
into simple microprotocols,
each of which is implemented by a protocol
layer. Protocol
layers can be stacked
on top of each other in a variety of ways, at run-time.
First,
we describe the classes of protocols
that can be supported
this way.
Next, we present the Horus object
model that
we designed for this technology,
and the interface
between
the layers that makes it all work.
We then present an example layer that implements
a group membership
protocol.
Next, we show how, given a set of required
properties,
an
appropriate
stack can be constructed.
We look at an example stack of protocols,
which provides fault-tolerant,
totally
ordered communication
between a group of processes. The
work contributes
a standard
framework
for protocol
development
and experimentation,
provides
a high performance
implementation
of the virtual
synchrony
model, and introduces a methodology
for increasing
the robustness
of the
protocol
development
process.
Introduction

Even when hidden,
message passing lies at the heart of
any distributed
system.
A tremendous
number
of message
passing interfaces
and protocols
have been developed
both
by the practical
and theoretical
computer
science community. Efforts to bring structure
to all this development
have
been only partially
successful.
Today, this lack of structure
impedes the engineering
of large, complex
distributed
systems.
For example,
a variety
of both fault-tolerance
and
multi-media
protocols
are readily available.
Yet it would be
tremendously
complex
to implement
a large fault-tolerant
multi-media
system.
The integration
of subsystems
that
provide different
protocols
into a working
whole requires intimate
knowledge
of the internals
of each subsystem,
and
considerable
creativity
to make them interplay.
as
Here, we adopt a perspective
that treats a protocol
an abstract
data type:
a software
module
with standard“This

work

was supported

by ARPA/ONR

grant

NOO014-92-J-

1866.
Permission

to make

di@al/hard

copies

personal or classroom use is granted
a~e not made or distributed for profit
right notice, the title of the publication
given that copyright is by permission
to republish, to post on servers or to
permission andlor fee.
w
C 95 Otbwa Ontario CA 01995

of all or part

of this material

for

without fce provided that the copies
or commercial advantage, the copyand its date appear, and notice is
of the ACM,
Inc. To copy otherwise,
redistribute to lists, requires specific
ACM

0-89791-710-3/95/08.

Science
*

ized top and bottom
interfaces.
Above a protocol
module
are other protocols
or applications
that issue requests to it.
The protocol
itself functions
by adding headers to messages,
or generating
new messages of its own, whereby it interacts
with the corresponding
module
on a remote system.
The
lower interface
permits
the module to receive incoming
messages, together
with other sorts of events.
In most systems,
this modular
structure
is obscured.
Each subsystem
may have its own top and bottom-level
interfaces, its own message data structure,
and its own methods of scheduling
internal
and external events. Interconnecting the different
interfaces,
converting
between the different
message formats,
and running
the different
schedulers
concurrently
arise as challenges
that the application
developer
must resolve.
Network
standardization
has focused mainly
on the message formats,
permitting
processes running
on
different
systems to communicate,
The seemingly
simpler
problem
of composing
subsystems
on the same operating
system has received much less attention.
The need is for a single system that has one message
format,
one event scheduler,
and a framework
allowing
protocol composition.
Composition
requires that the top-level
and bottom-level
interfaces
of the protocols
be identical
for
each layer, so they can be stacked on top of each other like
LEGO’m
blocks (see Figure 1). The protocol
interface
must
be sufficiently
strong to support
most protocols,
containing hooks with which the interface
can be extended
to add
new features.
Luckily,
work on object-oriented
systems has
addressed exactly these requirements.
If we can specify protocols in terms of objects,
then we can use existing
objectoriented
techniques
for composition
of these protocols.
The Horus system provides such an object-oriented
protocol composition
framework.
The system supports
objects
for communication
endpoints,
groups of communicating
endpoints, and messages. It currently
includes a library of about
thirty
different
protocols,
each providing
a particular
communication
feature.
Protocols
can be composed
in many
ways, alIowing
flexibility
and having the additional
advantage that an application
pays only for properties
it uses.
Horus can support
many applications
concurrently,
each of
which can be configured
individually.
Horus supports
nonHorus subsystems
by providing
a separate scheduling
environment
for each subsystem,
and a system-call
interception
technique
that traps system calls made by the subsystem.
This gives Horus complete
control over each subsystem
and
an inexpensive
way to communicate
with it.
Horus arose out of our prior work on fault-tolerant
process group computing
in Isis system [4]. Isis supports a oir-tu-

Abstract

1

in Horus

.$3.50

80

ally synchronous
process group communication
environment
in which software
fault-tolerance
was applied
to a variety
of problems.
Isis supported
process groups with mechanisms for joining
a group and obtaining
its state, leaving

bar, or a scroll bar.
These form new objects
that inherit
the basic interface
from the basic window object.
The basic
window
with its interface
and semantics
forms a class, and
each specialization
or extension
a subclass.
The concept is
generalized
by building
a tree of classes, the class hierarchg.
Protocols
also match this model.
We can start out with
a basic protocol
class that supports
best-effort
byte delivery over ATM or the Internet.
With this protocol,
messages
may be delayed,
lost, or garbled.
As we layer other protocols over such a laver. its moDerties
can be enhanced.
A simple protocol
th& adds a’ (l~rge enough) checksum to
each message could be used to reduce the garbling
problem to a statistically
insignificant
rate. Such a protocol
has
functionality
on both the sending side, where it adds the
checksum,
and on the receive side, where it drops the message if the checksum
does not match the contents
of the
message.
More interestingly,
the checksum
could be made
cryptographic
(i. e., dependent
on a secret key), making
it
impossible
for an malignant
intruder
to impersonate
a member process of the application.
The corresponding
protocol
model forms a subclass of simple communication
protocols.
Next in the class hierarchy
could be a protocol
that deals
with message loss and reordering.
By adding
a sequence
number to each message, a receiver can detect that messages
have been reordered
or lost. It can then request a retransacknowledgement
message.
mission by returning
a negative
This requires the sender to remember
each message it sent
until it knows that the message has arrived.
To give some
idea of what other protocols
may be needed in a complex
distributed
system, we provide a list of many of the protocol
types used in Horus (see Figure 1).
A communication
svstem. such as the Horus embeddinx
of virtually
synchrono&
process-groups
into UNIX socket;
is built by stacking a set of protocol
modules.
The top-most
module is the only one to deviate from the Horus interface
standard:
it converts
the Horus protocol
abstraction
into
one matchirw
the needs and expectations
of a user. Thus.

a group
(a f~ed
process is automatic~y
dropped
from
the groups to which it belonged),
and communicating
with
groups using atomic,
ordered
rnulticasts.
These primitive
functions
were used to support
tools for locking
and replicating data, load-balancing,
guaranteed
execution,
primarybackup
fault-tolerance,
parallel
computation,
and system
cent rol and management.
Horus focuses on the core of Isis,
implementing
a very powerful
process group communication
architecture
which can be used in support
of Isis-like tools,
embedded
into programming
languages or parallel
computing libraries,
or hidden
behind
standard
abstractions
such
as UNIX sockets.
In this paper we discuss Horus in relatively
practical
terms, omitting
theory that has been explored elsewhere and
pursuing
new theoretical
directions
suggested by Horus only
in a limited,
preliminary
fashion.
The paper describes a very
simple protocol
architecture
that is still powerful
enough to
support
the most important
styles of distributed
protocols
used in modern systems. It should be stressed that this layered architecture
does not imply
a high overhead;
indeed,
the cost of a layer can be as low as just a few instructions
at
runtime,
and a few bytes (or none at all) added to a message.
Our experience
with Horus bears this out: with reasonable
effort one can achieve performance
fully comparable
to the
best existing systems for similar environments
[15].
Although
much remains to be done, we have also started
to develop formal tools for specification
of protocol layers, as
well building
reference implementations
of the most critical
is a skeletal descripHorus layers. In this use, a specification
tion of the behavior
of a layer, giving the requirements
the
layer makes on layers above and below it, and the guarantees the layer provides in situations
where the requirements
implementation
is an formalized
version
hold.
A reference
of a layer, potentially
executable,
but developed
primarily
to facilitate
the use of formal
proof tools for verification.
Our specification
and reference language is a subset of ML,
while the language
of preference
for highly
optimized
versions of layers is C or C++.
Demanding
applications
would
normally
combine
gle high

when

3

use the more optimized
layers, which sometimes
the functions
of several reference layers into a sinperformance
production
version.
Our contention
is

Classes

module

the Horus

into

Horus

used

through

converts

socket

its
sendto

socket

interface,

and recvfrorn

the

top-

operations

paradigm.

Objects

We noted the need to standardize
the abstractions
used
by protocol
modules,
as well as their interfaces.
Among
other objects
outside
the scope of this paper,
Horus provides four classes of objects:
endpoints,
groups, messages,
and threads.
None of these objects, not even the group and
message objects, are distributed
objects.
That is, these objects only contain
state local to the process (or processor)
that owns them. (Of course, they may be used to implement
distributed
objects.)
The endpoint
object models the communicating
entity.
An endpoint
has an address, and can send and receive messages. As we will see later, messages are not addressed to
endpoints,
but to groups. The endpoint
address is used for
membership
purposes.
A process may have multiple
endpoints, each with its own stack of protocols.
Although
a single layer may be used concurrently
by
many groups and many endpoints
in the same process, each
this
instance has its own state. The group object maintains

that by providing
high level, executable,
descriptions
of key
parts of Horus, the system can be significantly
hardened.
This approach is discussed in detail in Section 8.
Horus is thus a multi-faceted
effort.
The project
seeks
to contribute
a powerful
and flexible programming
environment for distributed
application
development,
focusing
on
issues of fault-tolerance,
consistency
and security using process groups and (if desired) virtual
synchrony.
We do this in
a principled
and modular
manner that facilitates
the use of
our system to implement
protocols
with goals different
from
our own. Moreover,
Horus crest es a framework
within which
formal methods can be brought
to bear on such moblems
as
protocol
specification
and v~rification.

2

Horus”is

most

of Protocols

The classical example
of object-oriented
methodology
is a
window system. Starting
with a basic window,
one can construct extended windows with concepts like a border, a title

state
object

view,

81

on

a per-endpoint

is the

which

group

is a list

basis.

Associated

with

each

group

to which messages are sent; a
of endpoint
addresses which represent

address

B

All objects discussed so far maintain
state only. Horus
also provides
thread objects,
which perform
computations.
Horus threads are not bound to a particular
endpoint,
group,
or message object,
although
a thread will often deal with
at most one of each.
A process typically
contains
multiple threads, which come into existence in a variety of ways.
For example,
a thread can be explicitly
created by another
thread,
or may be created
by Horus to handle
an arriving message or some other event such as timer expiration.
Threads execute concurrently
and pre-emptively,
using mutual exclusion
to protect
critical
regions.
Thread
priorities
are supported,
but this raised many problems
(starvation,

TOTAL
I?4ST

m

MBRsHIp
MA.

m

NAK

COM

protocol

type

routing
/assem.

compression
checks umming
signing
flow control
retransmission

priority
inversion)
and their use is discouraged.
The threaded architecture
of Horus enhances performance
(through
increased concurrency)
and simplicity
(through
increased code modularity).
However, locking is also a source
of bugs in layers developed
by inexperienced
thread users.
This has led us to offer two very simple alternatives
to standard critical
sections.
The first of these treats a layer as a
monitor,
allowing
only one thread at a time to be active for
each group object.
The second is based on event counters,

used for
connection
fragments

signaling
fragment

m

large

setup
through

messages

into

internet
fragments

to improve
bandwidth
garbling
detection
safe communication

use

a

preventing
network
congestion
reliable
message Daswing

;eractions
r total
e bounds
ticipants
.
.

and
ber,
that

---. —..—ucatlon
7

accotiting

I keeping

and
will
We

a way
value:

threads

to order
each

are

be entered
have

also

threads

upcall

provided

with

in sequence
explored

according

is assigned
mutual

to an integer

a sequence

num-

exclusion

zones

approach

based

order.

a non-threaded

on an event queue model.
This model
associates queues
of invocation
parameters
with each entry point to a layer.
Rather than using a procedure
call to invoke a layer, a new
event is put on that layer’s event queue. Each layer is then
implement ed with a single scheduling
t bread per endpoint,
which is responsible
for selecting
(scheduling)
an event to
dequeue, and then for executing
the required
code. We find
that this leads to much simplified
code and reduced storage
overhead (the stacks used by threads are much smaller).

track oj

Figure
1: Protocol
layers can be stacked
LEGO’m
blocks. The table on the bottom
common protocol
types.

provides

sequencing

at run-time
like
contains a list of

4

Common

Protocol

Interface

For protocols
to be stacked in any order, it is necessary that
all protocol
implementations
use and supply
the same interface.
The Horus Common
Protocol
Interface
(HCPI)
is
designed to be rich enough to support
the features of most
protocols,
and has support
for optional
extensions.
HCPI
consists of a set of downcalls
and upcalls.
The interface
provides for multicasting
messages, installing
views, and reporting
error conditions.
The HCPI is designed for multiprocessing,
and is asynchronous
and reentrant.
See Tables 1
and 2 for a complete list of upcalls and downcalls.
The HCPI
allows users considerable
flexibility
in stacking the layers. Of
course, certain protocol
layers require that other layers be
stacked above or below them, as described in Section 6.
When creating
an endpoint,
a process describes, at runtime, what stack of protocols
it needs, and a base endpoint
to build it on. A process is allowed to put multiple
endpoints
on a single base endpoint.
This way, a tree or cactus stack
of protocols
can be built.
Given an endpoint
and a group
address, a process can join a group of endpoints.
Eventually, this results in a VIEW
upcall which describes the set
of endpoints
the process can communicate
with.
In case a
membership
layer is part of the stack, every endpoint
in the
view is guaranteed
to have been sent the same view.
Using the cast and send interfaces,
messages may be
broadcast
to the view of the group, or to a subset of the
view. In case of endpoints
joining
or crashing,
a view needs

the members of the group; and such additional
information
as may be needed by the layers stacked by the member that
owns the endpoint.
Locking
mechanisms,
described
below,
protect
the group object against concurrent
access, for example when threads in an application
issue concurrent
sends
to the same group object.
Since a group object is purely local, Horus allows different
endpoints
to have different
views
of the same group.
Note that we use the term “group”
to
mean the set of members
that communicate
using a common group address, whereas the “group
object”
is a data
structure
local to each member,
and associated
with that
member’s
communication
endpoint.
The message object is a local storage structure
optimized
for its purpose.
Its interface includes operations
to push and
pop protocol
headers, much like a stack. This should be expected, because headers are added as message objects travel
down the protocol
stack in the case of sending,
and are removed as they travel up in the case of delivery.
The message
object that is sent is different
from the message object that
is delivered,
although,
in most cases, they will contain
the
same data. A message object can contain
pointers
to data
located in the address space of the application,
the operating system, or even a device interface;
this permits
Horus to
pass messages up and down a stack with no copying of the
data that the message will actually
transport.

82

downcall

argument

endpoint

protocol

stack

join

endpoint

and

merge

view

merge denied
merge~ranted
view
cast

merge request
merge request
group handle, list of members
messaze

deny merge request
grant merge request
install a group view
multicast a messare

send

message
message
message

send message to subset
acknowledge
a message
message is stable

ack
stable
leave

description
and lower
group

join

contact

group

a communication

group

merge

and

subset

of members

leave

with

endpoint

and return
other

handle

view

group

remove members
and flush
go along with flush

handle

destroy

endpoint

clean

up endpoint

focus

identifier

focus

on layer

dump

group handle

dump layer information

Table

Upcall

Type

MERGEltEQUEST
MERGEDENIED
FLUSH
FLUSH.OK
VIEW
CAST
SEND
LEAVE
DESTROY
LOST-MESSAGE
STABLE
PROBLEM
SYSTEMERROR
EXIT

to be jiushed (see next section).
ways for different
layers.
A Membership

This

proceeds

1: Horus

and return

handle

downcalls

Information

Description

source
why
list of failed members

request t 0 merge
request denied
view flush started
flush completed
view installation
received multicast message
received subset message
member leaves
endpoint destroyed
message was lost
stability update
communicant ion problem
system error report
close down event

list of members
message and source
message and source
member id

stability
member
reason

Table

Example:

create

address

group handle
list of failed members

flush
flush-ok

5

endpoint

matrix
id

2: Horus

upcalls

the current view, and messages received in the current view
are received by all surviving
members in the current
view.
This is called virtual
synchrony,
because all members
that
can communicate
appear to see a failure at the same logical
time, significantly
reducing
the number of failure scenarios.
Virtual
synchrony
is best understood
as a simulation
of
fail-stop
behavior—members
excluded
from the view may
still be alive. When communication
is restored,
views may
be merged using the merge downcall.
Only if MBRSHIP
were used with a perfect failure detector
would this simulation be “accurate.”
MBRSHIP
relies only on reliable,
FIFO
ordering
of messages.
At the heart of the MBRSHIP
layer is the flush protocol.
The flush protocol
is run when a member crash is detected,
or when views merge.
One of the members
(usually
the
oldest surviving
member of the oldest view) is elected as the
coordinator
of the flushl
(see Figure
2). The coordinator
broadcasts
a FLUSH
message to the (surviving)
members

in different

Protocol

The Horus membership
protocol,
MBRSHIP,
shows most of
the special features of the Horus Common
Protocol
Interface.
Consider
a group of communicating
processes.
Because of various conditions,
not all member processes in the
group can communicate
with each other at all times.
Processes may crash, or the network
may partition.
Thus a
process may not be assured that a message it sends is received by all destination
members.
Nor can a process be
assured that a message it receives is received by other members in the destination
set. This introduces
a collection
of
failure scenarios that is difficult
to deal with.
The MBRSHIP
layer simulates
an environment
for the
members of a group in which members
can only fail (they
cannot be slow or get disconnected)
and messages do not
Each member
has a notion
of the current
view,
get lost.
which is an ordered list of the members.
Each member in
the current
view is guaranteed
either to accept that same
view, or to be removed from that view.
Messages sent in
the current
view are delivered
to the surviving
members of

1 By

picking

the

oldest

group

member

of the

oldest

view,

this

elec-

tion
can be performed
without
exchange
of messages.
Notice
that
the
concept
of “oldest”
might
not be meaningful
in an execution
model
where
different
procemea
obeerve
group
views
in different
orders
or
with

gaps.

statements

83

In
like

Horus,
this

the
in

virtual

a way

synchrony
that

is rigorously

model

enables
meaningful,

us to

make

B

A

crash detected

c

plication
requires in that environment.
We need a formal
way to describe what a layer requires from the layers above
and below it, and what it guarantees
in return.
A second
issue is to create a reference
implementation
of each layer to
formally
describe the algorithm
that implements
the layer’s
specification.
As a step towards this methodology,
we have begun compiling sets of properties
provided
by and required
by layers
(see Table 4). Table 3 lists, for each of a selected set of
protocol
layers, which properties
it requires,
and which it
implements.
In addition,
a layer may or may not pass a
property
through
to the layer above it. We call this inheritance. Given this table, it is possible to figure out if a stack
is well-formed,
and what properties
a well-formed
stack provides. A stack is well-formed
if, for each layer, all its required
properties
are guaranteed
by the stack underneath
it. The
properties
are either provided
by the layer immediately
below, or inherited
from an even lower layer. Vice versa, given
a set of network
properties
and required
properties
for an

D

. . -----~..lost
. . . . . . . . . . . ----” -.”...-.---Iost
flush

>

send copy of M

ok

send copy of M
instali new view

application, it is possible to figure out if a stack exists that
can implement
the requirements.
If we can associate a cost
with each of the properties,
possibly
on a per-layer
basis,
we can even create a minimal
stack. Rather than looking
at
this as stacking
protocols
on top of each other, a different
interpretation
is that Horus actually
builds a single Protocol
for the particular
application
on the fly.
We note the similarity
between
this methodology
and
an approach
that is commonly
used when developing
realtime systems. In a real-time
system, an application
requests
timing
properties.
The system will try to reserve the necessary resources to guarantee
these properties.
If successful,
the application
is started.
If not, an error is returned
to the
user. Horus can generfllze
this idea: an application
requests
a set of properties
first, and then Horus can figure out if it
can guarantee
this properties.
We are currently
working
on designing
formal
methods,
so that on a per layer basis we can verify that given a set
of underlying
properties,
it provides a new set of properties.
We are also interested
in verifying
whether
a layer leaves

Figure 2: This picture
shows four processes: A, B, C, and
D.- D crashes right
after sending
a message M, and only
C received a copy. After the crash is detected,
A starts the
flush protocol
by multicasting
to B and C. C sends a copy of
M to A, which forwards it to B. After A has received replies
from everyone, it installs
a new view by multicasting.

in its view.
All members
first return
any messages from
failed members that are not known to have been delivered
(note that
everywhere.
These messages are called unstab/e
it is necessary that all members log all unstable
messages).
Finally,
each member returns a FLUSH_OK
reply message.
Subsequently,
the members ignore messages that they may
receive from supposedly
failed members,
and await another
VIEW
installation.
Upon receiving
all FLUSH-OK
replies, the coordinator
broadcasts
any messages from faiIed members that are still
unstable.
At this point a new view may be installed.
When
all messages stabilize,
the flush is completed.
If processes
fail during
the process, a new round of the flush protocol
may start up immediately.
Although
the MBRSHIP
layer is able to do its own failure
faiksre
detection.
In this case,
recovery, it allows for external
an external service picks up communication
problem-reports
and other failure information,
and decides whether a process
is to be considered
faulty or not. The output
of this service
can be fed to all instances
of the MBRSHIP
layer, so that
the corresponding
groups have the same (consistent)
view
of the environment.
The MBRSHIP
and MERGE
layers raise an interesting
issue concerning
the handling
of partitioning
failures in Horus. We return to this question
below, in Section 9.

6

Protocol

Properties

and

certain

properties

preliminary

7

Example:

efforts

untouched
in this

A Typical

(inherit
direction

Protocol

ante).
in Section

We

discuss

our

8.

Stack

In this section we look at a typical
stack, namely
TOTAL:
MBRSHIP:FRAG:NAK:
COM:ATM.
In this stack,
COM provides
unreliable
communication
over a low-level
network
of choice; ATM was selected in the example.
NAK
provides
FIFO ordering
using a sequence number,
FRAG
provides
fragmentation
and reassembly
of large messages,
MBRSHIP
provides
virtually
synchronous
communication
with respect to group membership,
and TOTAL
provides
totally
ordered communication
within
group memberships.
If we know that ATM only provides property
PI of Table 4,
then we can quickly find from Table 3 that this stack results
in the properties
P3, P4, P6, P8, P9, PIO, f’11, P12, and P15.
This section will visit each of these layers in turn and clarify
why these properties
are obtained.
The COM, NAK,
and FRAG layers do not provide consistent views.
A view at these layers is nothing
but the
set of destination
endpoints
for multicast
messages.
The
COM layer translates
the low-level
network
interface
into
the Common
Protocol
Interface.
If necessary, COM keeps
track of the source of messages (by pushing
the address of

Inheritance

For a given application
that is to be installed
over a network with
a given set of properties,
one needs to find a
stack of protocols
that will provide
the properties
the ap-

84

I

Layer

(R)equires
II 1 I 213141516171819

MERGE

IIRI

IRIRI

II

110111112113114[15 I16][ 1 I 2131415

IRI

IRIRIRIRIRI

Table 3: This table lists, for each of a selection of Horus protocols,
protocol,
the properties
that are inheritedfrom
that communication,
Table 4 for the list of properties).

E=====a
virtually

P9

Plo
Pll
—
P12

P13

semi-synchronous

delivery

virtually
synchronous
delivery
byte re-ordering
detection
source address
large messages
causal timestamps

stabilitv
information
consistent
views
P15
view memirw
P, 8 I automatic

P, 4

Table 4:
either be
provided
provided

A list of protocol
properties,
each of which can
a requirement
on the communication
guarantees
underneath
the protocol,
or a guarantee
that is
bythe
protocol
itself.

the source endpoint
on each outgoing
message), and filters
out spurious messages from endpoints
not in its view.
The NAKlayer
provides FIFO ordering of messages. For
this it pushes asequence
number on each outgoing
message,
that the receiver can check. If the receiver detects message
loss, it sends back a negative acknowledgement
(NAK).
The
NAK
layer buffers some messages for retransmission,
and
will retransmit
if the message is still buffered.
If not, it will
send a place holder that will result in a LOST-MESSAGE
event when received.
Each endpoint
will occasionally
multicast its protocol status, so buffered messages may be flushed,
and window-based
flow control mav beimdernented.
It also
allows the detection
of failures or”discon{ections
(in case a
status update is not received in time).

(I)nherits/(P)rovides
\ 6171819
110111112113114115116

11111111111111111111111111

the requirementson
andthe
properties

lIlp

the communication
underneath
that areprovided
by the protocol

the
(see

The FRAG layer provides fragmentation
and reassembly
of large messages. Typical
networks have a limit on the size
of messages they can transmit.
When a user of the FR.AG
layer attempts
to send a message that is larger than that
maximum
size, the FRAG layer splits the message into multiple fragments.
On each fragment
the FRAG layer pushes a
boolean value that indicates whether it is the last one or not.
The FRAGlayer
dependson
FIFO ordering
for reassembly.
When the last fragment
is received, it delivers the message.
The MBRSHIP
layer has been discussed in the previous
section. It adds strong semantics
to the VIEW
upcall, that
is, it guarantees
that all members in the view that were also
in the previous
view have delivered
the same messages.
It
relies on the FIFO ordering provided
by the NAK layer, and
on the FRAG layer for sending large messages.
The TOTAL
layer, in turn, relies on virtually
synchronous
communication.
During
normal
operation,
it utilizes
a token. A special ‘(oracle” ateachmember
decides who should
get the token next. The oracle cannot always make theoptimal deckion
for minimal
overhead,
but the protocol
that
the TOTAL
layer uses comes close in many cases. In case
of a failure,
the token may be lost.
This, however,
is not
a problem.
During
the flush, all members that did not get
the token in time send their messages. These messages are
not delivered,
but buffered.
When the new view is installed,
each member that remains connected
to the system is guaranteed to have all messages from the previous
view, and a
deterministic
order can easily be constructed
( e.g,, messages
are delivered
in the order of the rank of the source).
Another deterministic
rule decides who the first token holder
in this view is (e.g., the lowest ranked member),
and normal
operation
can continue.
Interestingly,
the TOTAL
layer does not require direct
interaction
with a failure detector.
As providing
totally
ordered communication
is equivalent
to the consensus problem, this seems contrary
to the impossibility
proof of [7].
TOTAL
works nevertheless,
for two reasons.
First, the semantics that the TOTAL
layer provides are slightly
weaker,
since

it

only

guarantees

members
in the view.
vided by the MB RSHIP

85

II

timely

delivery

to

the

surviving

Second, failure
information
is prolayer in the form of view updates.

8

Reference

Implementation

stance, a production
layer should be replaceable
in a protocol stack by its corresponding
reference layer and vice versa.
Interoperability
allows us to take advantage
of the existing
production
version and follow
an incremental
approach
so
that “hardening”
of key components
can be tackled first and
non-essential
pieces left for later.
Also, new protocol
layers
can be rapidly
prototype
in ML, tested with a normal Horus protocol
stack, and then translated
to C if performance
is an issue. In addition
to protocol
layers, distributed
applications can also be written
in ML using the interface.
Initial
experience
shows that the goals we have set for a
reference implementation
of Horus can be reached. We have
built reference implementations
for several protocol
layers.
These are considerably
cleaner than the current production
layers and are generally
an order of magnitude
smaller in
code size.
We believe we will be able to completely
implement
the core of Horus in a few thousand
lines of ML
(compared
to 40-50,000 lines of C) for the purpose of verification.
In addition,
the implementation
of reference layers
has led to several improvements
in the basic Horus architecture,
some of which may result in improved
performance
when translated
back to the production
layers.
We have only begun to explore the issues that arise in
actually
proving
that a layer satisfies its specification,
and
that a set of specifications
can be combined
to implement
a
desired property—for
example, that layers can be composed,
in the formal
sense. Our initial
work on this problem
uses
1/0 automata
(similar
to the model expounded
by Nancy
Lynch et al. [6], with certain modifications
suitable
to the
Horus architecture)
to model the protocol
executed by a Horus layer.
Important
properties
provided
by the layer can
then be verified by combining
this 1/0 automaton
with other
1/0 automata
representing
all the layers above and below
it. The composition
of these automata
(itself an automaton) is a closed system, which we augment
with additional
properties
(such as fairness)
expressed in simple temporal
logic formulas
over states and actions.
We then prove that,
within
this system, the layer honors a specified set of user
requirements.
A similar
technique
will allow us to verify
that desirable
properties
of a given protocol
stack will be
preserved by the addition
of a new layer, and to help decide
when the stacking order of two layers matters.

Effort

As part ofour
effort to verify properties
of the Horuscommunication
system, we are building
reference implementationsof
Horus protocol layers. Reference layers serve as concise specifications
of the current
“production))
layers, but,
despite the appearance
ofpseudo-code,
are also executable.
The layers are written
in the ML programming
language,
a
high level language
that supports
features
useful for communication
systems:
eg., automatic
marshaling
and static
type checking of messages. ML also has a formal definition
making it amenable to analysis, including
program
verification in theorem
proving
systems such as Nuprl
and PVS.
Because ML is typically
slower than C,the
reference layers
will not attain
the full performance
of the production
layers (which are written
in C). Although
we are not verifying
the production
layers directly,
we want to emphasize
that
we are discussing
the verification
of real, executable
implementations
of distributed
Such verified reference
.rnotocols.
implementations
can be used primarily
in two ways. First,
they can be used in place of C code to save development
effort but sacrifice performance.
Second, the reference implementations
can retranslated
back toC, yielding
production Horus components
with a considerably
increased level
of verification.
Viewed from a broader perspective,
ourreferenceimplementation
of Horus demonstrates
a possible
methodology
for refining
and verifying
a class of complex
but modular
communication
systems.
Such a methodology
responds to
the difficulties
of applying
a comparable
process to large
svstems written
in C. Our amxoach
is to translate
an alr~adyexisting
system toahi~~leve
llanguage (such as ML)
which is amenable to the refinement
and verification
needed
to “harden”
the system. This will rarely require a complete
verification
of the system, but rather
entails a continuing
process of proving
the complex and uncertain
properties
of
the system, so that the remaining
subgoals
are more and
more obviously
true.
Once the reference implementation
has been built,
refined, and verified,
we translate
it back to C as a new production
implementation
to achieve the high performance
of
the original
implementation
but now with a much greater
confidence
in its correctness.
In so doing, layers may be
combined
and other optimizations
applied.
However, we do
not “throw
away)’ the reference implementation
when this
process is complete because it continues
to be useful as documentation
and as a specification
of the system, as welI as
a vehicle for further
verification
and prototyping.
The continued
use of production
versions of layers is a
concession
to the performance
requirements
of demanding
applications.
However some applications
seek the utmost in
reliability,
at least with respect to properties
such as security. For this reason, another important
goal for Horus reference layers is that they be interoperable
and interchangeable with the production
layers.
We have constructed
an
interface
between Horus and ML so that reference and production layers can be mixed freely in a protocol
stack. Such
an interface
is possible only because of the HCPI, to which
all layers adhere.
Our approach
would
permit
a fully
verified
reference
layer that implements
a security protocol
to be inserted into
a production
Horus protocol
stack, even though one is implemented
in ML and the others are in C. Interchangeability
both encourages
and enforces a tight coupling
between the
reference and production
implementations
of layers. For in-

9

The

End-to-End

Argument

Several readers of preliminary
versions of this paper raised
questions
about the end-to-end
argument
and the controversy over causal and total ordering
in communication
systems (catocs), asking whether our work on Horus sheds new
light on these issues [5]. Before we address these issues directly, we should point out that Horus supports
everything
from best effort delivery to very strong semantics,
and users
can decide for themselves
whether
they need causal or total
ordering,
or not. Moreover,
Horus (and several other catocs
Systems) ~o= provide
a true end-to-end
form of message stability.
is called
stable
if it has
A message
all its
that

surviving
are

included

destination
in

the

processes
next

view).

mechanism
been

(that
The

in the

processed

is, the
term

by

processes
“has

been

here. Horus provides a downcall,
horus-ack(m),
with which the application
process informs
Horus when it has processed the message m. Eventually,
this information
propagates
back to the sender of the message, and onwards
to other receivers of the message.
It is
processed”

86

is instrumental

reDorted
usirw a STABLE
t &ed inform~tion
about

uDcall.

the-stability

The

uDcall contains
deof ~he messages that

and implements
higher level programming
abstractions.
In
the case of Horus, the abstraction
of choice is the virtually
synchronous
process group, with ordered and failure-atomic
mult icast (alt bough, as we have stressed, one can easily configure Horus to have other properties,
and can selectively
enable or disable any of these basic properties).
Finally,
at the third tier, one finds applications
that depend on the
consistency
properties
of the underlying
structure.
There are at least three different
implementations
of the
first-tier
that would be suitable
for use in Horus.
The Isis
system employed
a group membership
protocol
that provides consistent
reporting
of system membership
changes
wit hin a primary
partition
[12, 8]. The Transis and Totem
systems implement
an extended
virtually
synchronous
addressing
model,
corresponding
to a partitioning
model in
which the primary
partition
is distinguished
but that also
allows progress in non-primary
partitions
[10]. The Relacs
system implements
a “quasi-partial”
view synchrony
model.
In this approach,
concurrent
membership
views will either
be identical
or non-overlapping
[1]. Currently,
Horus can be
configured
with an Isis-style
of primary
partition
progress
restriction,
or to support
the extended
virtual
synchrony
model.
A new membership
layer that uses the view synchrony scheme of Relacs can easily be added.
Elimination
of the membership
agreement
mechanism,
on the other hand, introduces
the risk of potentially
serious inconsistencies.
For example,
we pointed
out in Section
7 that liveness of the TOTAL
ordering
layer is dependent
upon the membership
service and that the uniqueness
of
the ordering
token is guaranteed
by exploiting
consistency
in the views supplied
by MBRSHIP
to that layer. Given inconsistent
views, TOTAL
might not be live, or it might give
different
message orderings
to different
endpoints.
Horus
is thus flexible
about the specific partitioning
model used,
but inflexible
about its need for a close approximation
to
fail-stop
behavior.
This leads us back to the end-to-end
dispute.
Proponents of the end-to-end
argument
maintain
that each application program,
or each client-server
pair, should cooperate
to maintain
the properties
needed for their particular
purpose.
In an end-to-end
mindset,
none of the partitioning
and membership
options
cited above would be acceptable.
Each requires a system-wide
consensus mechanism
form aintaining
membership
views, closely integrated
into all levels
of the communication
hierarchy.
Yet, in the absence of such
consensus, it appears to be impossible
to provide consistent
behavior
at the upper tiers of the hierarchy!
We would argue that the onus falls on the end-to-end
community
to demonstrate
meaningful
ways to achieve consistency within
their paradigm.
For example,
it is straightforward
to implement
replicated
data, fault-tolerant
synchronization,
or high availability
of critical
servers in Horus.
Horus achieves the necessary consistency
guarantees
through
ordering
and atomicity
properties
provided
by its
process group and communication
protocols.
These, in turn,
depend upon the most basic membership
agreement
mechanisms.
We conjecture
that such a dependency
structure
is necessary, and that in its absence, non-trivial
consistency
guarantees
cannot be provided.
If we are correct, this would
support
the conclusion
that end-to-end
architectures
are inherently less powerful
than architectures
based on a rigorous
system membership
service.

a process

sent, or received, in the form of a so-called stabilDepending
on the application,
a message could
be considered
stable when it has been displayed
to a user,
logged to disk, when it is safe to delete, etc.
The stability
matrix
thus reports a property
that is completely defined by the application
layer. The “semantics”
of
stability
data are exactly the semantics
determined
by the
downcalls
issued by the application
to Horus.
We see this
as an illustration
of the end-to-end
paradigm
as it is used
within
Horus: the st abfit y layer provides a mechanism
that,
under control
of the application,
may have widely
varying
meaning.
Back to the concerns that were raised in [5]. Briefly, their
use of the end-to-end
argument
has come under scrutiny
from researchers,
including
ourselves,
who favor communication systems that guarantee properties
such as virtual
synchrony [3], or ordering.
The argument
favoring
“properties”
is that the complexity
of implementing
these in the application itself can be daunting,
and that,
unless properties
are standardized
throughout
a communication
framework
it
will be impractical
to extend a system with new applications
that depend upon communication
properties
over time.
One example is an application
which is designed to communicate
synchronously
with a service, but in which replies
to the messages being sent are not needed.
An application that updates a display maintained
by a remote display
server matches this model.
Provided
that the message delivery order and reliability
properties
are maintained,
such
an application
could gain improved
performance
by using an
asynchronous
communication
stream.
Given an application
consisting
of a single process, one could simply
use a reliable, FIFO protocol
such as TCP to communicate
with the
server.
Now, suppose that the application
is composed
of
multiple
processes that communicate
among themselves—
an increasingly
common
architecture.
The FIFO ordering
property
now generalizes,
becoming
a requirement
for reliable causally ordered message delivery
[14]. Given a communication
subsystem
that supports
causal order, the benefit
of asynchronous
communication
can be exploited;
lacking it,
this performance
benefit is not available.
In a superficial
sense, Horus could be considered
as a
contribution
to either side of the fence.
Because Horus is
often used as a library,
it will often be linked
directly
to
the application.
Configured
in this manner, one could argue
that Horus is consistent
with a philosophy
in which the end
ity

matrix.

application
implements
its own properties,
as illustrated
by
the stability
example,
above.
However,
Horus also employs system-wide
services, and
provides ordering properties
and reliabihty.
Viewed as a runtime environment
or a sort of distributed
operating
system
for robust application
development,
Horus takes on a role of
a communication
layer and associated services guaranteeing
a variety of properties.
In this deeper sense, it could be argued that a system like
Horus could not be implemented
using an approach
fully
consistent
with the end-to-end
philosophy.
Although
the
present paper has not focused on protocols,
our previous
work has discussed the Horus virtual
synchrony
implementation in considerable
detail.
One can view systems such as
this as having a three-tier
structure.
The lowest tier simulates a fai-stop
environment
(consistent
membership
tracking with accurate
notifications
when membership
changes
occur).
The second tier closely resembles a state machine,

87

10

Performance

a process group through
a standard
UNIX sockets interface
(e.g. a UNIX
sendto
operation
will be mapped
to a multicast, and a recvfiom will receive the next incoming
message).
A similar
approach
could be used to hide Horus beneath
a
file system interface,
much as in the operating
system called
Plan/9.
Horus has also been embedded into object oriented
languages,
such as ORCA and the Electra version of C++.
Horus stacks exist to support the virtual
synchrony model,
as well as weaker, less ordered,
or less reliable
communication models.
Horus can thus emulate our older Isis Toolkit,
but can also be presented through
interfaces
matching
those
of the Hebrew University’s
Transis system. Very lightweight
protocol
stacks permit
Horus users to obtain
the performance of an ATM network with almost no overhead at all. A
security
architecture
for Horus provides
for authentication
and encryption
of messages, using a novel approach
that
combines security features with fault-tolerance.
Looking
to
the future, we will be adding protocol
layers to support guarantees of throughput
and low latency, which require resource
allocation
and scheduling
mechanisms
within
the system.
Coordination
of behaviors
between stacks, in systems that
use several stacks simultaneously,
has emerged w a topic for
future study.
Finally,
as noted earlier, the Horus architecture
promotes
the decomposition
of protocols into independent
layered modules with clear structure
and standard
interfaces.
For example, in the past, our work on Isis was clouded by an architecture
in which protocols
for group communication
were
“mixed”
with protocols
for membership
agreement.
In Horus, the system membership
service is supported
as a layer
which uses potentially
inaccurate
failure
suspicions
as well
as member join (actually,
view merge) and leave events to
create the abstraction
of a fal-st op environment.

and Overhead

The extensive use of layering
raises important
performance
issuesin Horus. On the one hand, the layering
irnprovesperformance,
since applications
can choose the minimal
stack
for their requirements.
For example,
an application
can decide whether
or not it needs end-to-end
guarantees,
and, if
so, whether STABLE
or PINWHEEL
will be optimal.
Also,
because each layer is small and simple, they can easily and
effectively
be optimized
individually.
Although
the performance of Horus currently
compares very favorably
to other
systems (see [15]), performance
could still be improved.
The
performance
of the current
system suffers for the following
reasons:
1. There

is an indirect
boundary
is crossed.

procedure

call

each time

a layer

multiple
procedure
calls
2. Since Horus is thread-safe,
into the same layer often have to be synchronized
by a
lock. To avoid deadlock,
it is sometimes
necessary to
invoke an upcall as a thread.
3. Layers push their own header onto the message.
For
convenience,
this header is aligned to a word boundary.
This leads to a considerable
overhead of unused bits on
messages that need be transfered.
Also, each pop and
push operation
has an associated overhead.
We have no detailed
overhead
measurement,
but can
of the fragment areport
that on a Spare 10 the overhead
tion/reassembly
layer FRAG
(which only needs one bit of
header space) adds about 50 ,usecs to the one-way latency,
which is considerable.
We believe we could bring this down
somewhat
by more careful coding,
but we are working
on
more rigorous solutions
to each of these problems.
For the first problem,
we will avoid unnecessary
invocations of a layer, skipping
layers that take no action on the
way down or up. We also envision
that it will be possible
to take common
substacks of protocols,
and (from the reference implementation)
create one single production
layer.
Ideally,
a compiler
might implement
optimizations
such as
these.
To address the second problem,
we are eliminating
intrastack threading,
having discovered
that concurrency
within
a stack does not lead to significant
gains. This way we can
reduce the use of locks and the frequency
of thread creation,
except when entering
a stack from the top or bottom.
Since
synchronization
between stacks is seldom necessary, we can
still run each stack within
its own thread.
For the last problem,
we are changing
the protocol
implementations.
A protocol
wilI specify, instead of the layout
of their header, the fields that it needs (in terms of size and
alignment,
both specified in bits).
When building
a stack,
Horus wiU precompute
a single header in which the necessary

fields

are

on a message
and

11

pop

compacted.
to a minimum,

operations

Status

currently

This

should

and
used

reduce

eliminate
by most

the

wasted
header

Thus, the membership
layer sees two kinds of inputs:
inaccurate
failure
and merge events.
Its output
are failure
and merge events that have been filtered
by a membership
appropriate
uniform
could
will

agreement
in

be used

here.

see merge

and

also
also

bership

change

events.

Such

extend,

but

ular

it

posed

set

events

our

case,

can

will

an approach
thus
be made

of protocols

dynamically
although

A protocol
leave

over

events,

but

be indistinguishable
is not

just
and

encourages

what

and

a failure

the

layer
mem-

fail-stop

to implement
about.

a theoretical

precise

this

these
from

easier
reason

sequenced
protocols

other

operating

input

also to understand

framework

which

protocol—a

agreement

The

perspective

semantics

detector

or
modin

of a comare,

layer

by

layer.
This
leads
to another
major
challenge
for future
work.
Notice that the membership
services discussed above each
implement
a complex protocol
that converts merge and failure events with weak semantics
to merge and failure events
with much stronger
(simpler)
semantics.
This process of filtering a complex environment
to create a simpler one is not
what one would intuitively
expect from the composition
of
protocol
layers.
After
all, composition
should in the general case yield layers with semantics
much more complex
than those of any of the constituent
layers. We believe that
the issue of how composition
leads to simplicity,
in a formal
sense, emerges as an extremely
interesting
opportunity
for
future study. We would argue that, in showing how complex
protocols
can be simplified
using modular
techniques,
Horus
takes a very positive
step in the desired direction.

space
push

layers.

and Challenges

The Horus system is fully operational,
although
we are continuing
to extend it with new kinds of protocol
stacks. The
current
system can be accessed through
a variety
of userlevel interfaces.
In addition
to the HCPI, Horus can present

88

12

Related

Work

[2]

We are not the first
nication

for composing
[13].

In

and

two

each

pair

is for

to realize

protocols

a set of protocols

this

approach,

reliable,

of consecutive

ries

protocol
support

tunities

the

control

for

messages.

concurrency.

as the

designed

A

down

ration

is done

safety,

and

dress

spaces.

tions,

and

Horus

In both

protocol

ations,

and

does

address

with

does

limited

[4]

oppor-

in

group

the

the

for

over

was

simple

always

providing
may

not

provide

implementing

protocols,
tion
the

prototypes

FOX

systems

takes

this

performance

approach,
selves.

it

easy

to

the

ber

[6]

way.

Their

problems

while

we

are

opera-

[7]

x-kernel,

the

control
both

dif-

of system

Cooper

been

here.

towards
further

research

ML

interested

in

and

involved

Barry

overcoming

because

the

protocols

of this

pages

with

particularly

Proc.

An

van
the

Renesse.

Isis

the

CA,

Understanding

totally

ordered

Fourteenth

Principles,

Syrnp.
NC,

appeared

the

communi-

ACM

Asheville,

version

Reii-

IEEE
1994.

Toolkit.

Los Alamitos,

and

of

earlier

on

Decem-

as Stanford

STAN-CS-93-1485,

this
thank

work,

Michael

a list

Dalia

January

models

C’ornputer,

J. Fischer,

Sept.

CS

1993.

of communication

26(8):37-47,

Nancy

Impossibility
process.

A.

Lynch,

1993.

and

y of distributed

Journal

services:

August

Michael

consensus

of the ACM,

S.
with

32(2):374–382,

1985.

Syrnp.

on

Principles

Diego,

CA,

August

of

Distributed

1994. ACM

ACM

San

Computing,

SIGOPS-SIGACT.

L. Peterson,
and
with
modularity

and

Aleta
Dis-

ILrperience,

Richard
D,
in Consul.

23(10):1050-1075,

1993.

Ivat.

pages

[12]

on

Distributed

Operating

Systems
November

AZ,

Aleta

Rlcciardi,

man.

Understanding

[13] Dennis

too

on

Poznan,

Park,

assumption.

Andre

In

Trends

Computing

Poland,

June

Principles,

Sys-

1994. IEEE.

Proc.

Schiper,
of the

pages

91--101,

1989.

partitions

of Distributed

and
and

Fourth
Systems,

Kenneth
the

IEEE

“no

P.

Workshop

Lisboa,

Bir-

partition”
on

Portugal,

1993.

M. Ritchie.

Laboratories

Malki,

Conf.

56-65,

Larry L. Peterson,
Norm Hutchinson,
Sean O’Mrdley,
and Mark Abbot t. RPC in the x-Kernel:
Evaluating
of the Twelfth
ACM
new design techniques.
In Proc.
Syrnp.

[14]

IEEE,

Formal

study.

Litchfield

Gleeson.

612–621.

Jan-

[10] L. E. Moser, Y. Amir,
P. M. Melliar-Smith,
and D. A.
Agarwal.
Extended
virtual
synchrony.
In Proc. of the

them-

A stream

Technical

Robbert
van Renesse.
operating
St.-Michel.
April
1993.

input-output

.lourrd,

Causal
Systems

system.

63(8):1897-1910,

controversy
Reuiew,

Bell
1984.

at Le Mont
27(2):44-53,

[15] Robbert
van Renesse, Takako
M. Hickey,
and Kenneth P. Birman.
Design and performance
of Horus:
A lightweight
group communications
system. Technical
Report 94-1442, Cornell University,
Dept. of Computer
Science, August
1994.

Babao/.jlu,
R. Davoli,
L. A. Giachini,
and M. G.
Baker. Relacs: A communication
infrastructure
for constructing
reliable applications
in large-scale
distributed
Int.
Conf.
on Syssystems. In Pvoc. of the 28th Hawaii
Sciences,

and
commu-

28(1):11–21,

and Dale Skeen.

Report

October

O.

tem

in

Cheriton

ordered

Review,

with

Press,

Software—Practice

produc-

References
[1]

to

totally

Robbert

[9] Shivakan
Mishra,
Larry
Schlichting.
Experience

of our

building

involves

are incurred

such

as a tool

verification
by

that

We

and

Systems

September

have

appeared

[8] Dalia Malkl,
Ken Birman,
Andre
Schiper,
and
Uniform
Actions
in Asynchronous
Ricciardi.
of the Fourteenth
tributed
Systems.
In Proc.

Acknowledgements

Robert

In

Fekete.

April

[11]

include

Mel-

Also

response

Computing

of causally

Fourteenth

people

ML.

Carnegie

severely

services

we use

Alan

Future

to

Birman

R. Cheriton

one faulty

oper-

Conclusion

Many

1994.

and

Systems

Society

Patterson.

The development
of critical
reliability
distributed
systems
has emerged as an important
chalIenge,
and demands
new
tools for distributed
software
development.
The modular,
layered architecture
of Horus encourages simplicity
and rigor
in the development
process. At the same time, applications
pay only for protocol
properties
they need, leading
to extremely
high performance
and flexibility.

long

P.

1993.

tems,

13

A

of causal

Distributed

A case

ad-

can be mixed

format,

While

and

Kenneth

Research

thread-

multiple

control

different

address

a step

PA,

Birman.

Operating

Operating

configu-

full

span
layers

and

ML.

P.

limitations
cations.

mainly

even

x-kernel,

that

implementation

Standard

Pittsburgh,

criticism

[5] David

communi-

such configuration
flexibility.
We note that a followon to the z-kernel project,
called Consul [9], is attempting
to deal with some of these disadvantages
by supporting
sophisticated
micro-protocols
between protocol
modules.
the FOX
project
[2], which
Our work with ML parallels
as TCP/IP

in Standard

’94.

Computer

limiting

is investigating

TCP

at run-time.

many

own

A structured

CMU-CS-FOX-94-05,

1994.

able

sophisticated

and

format,

supply

their

uary

car-

however,
more

by

STREAMS

modules
design

nication.

z-kernel

not
work

messages

has one single

matched.

channels

channel

is not

Also,

this

supporting

ferent

of these
other

but

communication

on

Since

Skeen’s

up

[11]. In this system,
protocol
in acyclic
graphs.
Horus
was

at compile-time,

improves

[3] Kenneth

communication,

interface.

University,

SIGCOMM

linearly,

has

abstraction.

style
this

lon

between

and

but

Report

framework

STREAMS,

related

Biagioni.

placed

are
the

commu-

framework

lined

One

wkernel,

fundamental

to

Horus

and

from

for point-to-point

request-response
map

are

communication

by ideas

cation

STREAMS

while

approach
is used in the z-kernel
objects
can be linked
together
motivated

is the
channels

data,

for

best-known

protocols.

user

group

a framework

The

protocols

sequenced

transporting

not

that

is necessary.

Edoardo
Technical

1995.

89

