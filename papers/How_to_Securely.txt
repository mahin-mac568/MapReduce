How to Securely Replicate
MICHAEL

K. REITER

AT& T Bell Laboratories
and
KENNETH
Cornell

P. BIRMAN

University

We present
integrity
failing
We

a method

despite
benignly.

a security

in

counter

the

this

attack.

a single

service

An important

key for the service

implemented

from

an

processed

by

and novel
even

using

corrupted

feature

a single

that

retain

a causal

intruder’s
the

service

Instead,

We demonstrate

among
to

and

availability

in addition

order

ability

of our techniques

server.

their

by an intruder,

of maintaining

resulting

of requests

services

being

the Issue

or authenticate

public

we have

replicated

and clients

breach

sequence

be able to identify
only

constructing

servers

We also address

illustrate

causahty

for

several

propose
is that

the client

the performance

client

effect

and

to others
requests.

a violation
an

of

approach

the client

is required

need

to
not

to possess

of our techniques

with

a

one of our protocols.

and
SubJect
Descriptors:
C.2.O
[Computer-Communication
Networks]:
C.2.4 [Computer-Communication
Networks]: Distributed
General—secwvty and protection;
Systems; D.4.5 [Operating Systems]: Reliabihty-fazd~ -~olwcsnce:D.4.6 [Operating Systems]:
controls:
K.6.5 [Management
of ComSecurity and Protection—au~lzen tzcation; cryptographic
puting and Information
Systems]: Security and Protection—au~~en~tca~~on
Categories

General Terms: Reliability,

Security

Additional Key Words and Phrases: Causality, replication, state machmes, threshold cryptography

1. INTRODUCTION
Distributed

systems

are often

structured

in terms

This

work

1866,

was supported

grants

Fellowship

from
Any

by DARPA/NASA

GTE,

IBM,

conclusions

and

Authors’
ment

addresses:

Road,

of Computer

Permission
not made
of the

M.

Holmdel,

K.

NJ

publication

and

its

permission.

01994

ACM

ACM Transact,.m

the

and

NY

date

appear,

on Progamm,ng

and

email:

of the

in this
National

Laboratories,

A

ken@cs.cornell.

material

is granted
the ACM

is ~ven

To copy otherwise,

that

NOOO14-92-J-

Foundation

document
Science

Room

advantage,
notice

services.

grant

Science

reiter@research.att.tom;

of this

commercial

Machinery.

0164-0925/94/0500-0986

Bell

email:
14853;

DARPA/ONR

a National

expressed

views

AT&T

fee all or part

for direct

for Computing

specific

Reiter,

Ithaca,

to copy without

Association

reflect

07733-3030;

Science,

or distributed

NAG2-593,

Inc.,

or recommendations

authors
and do not necessarily
Department
of Defense.
Corner

grant

Siemens,

and

of clients

requests
to
clients invoke by issuing
the service may return
an appropri-

service exports a set of commands,
which
the service. After executing
a command,

Graduate

are those
Foundation

4F-637,

101

K. P

Birman,

of the
or the

Crawfords
Depart-

edu,
prowded
copyright

copying

or to republish,

that
notice

the copies

is by permission
requires

$03,50

Languages and Systems, Vd 16, No 3, May 1994, Pages 9S6-1009

are

and the title
of the

a fee and\or

How to Securely Replicate Services
ate

response

to the

client

that

invoked

the service is implemented
by only
reliable,
however,
then the service
In hostile
ular,
many

more

distributed

only

a single

Habibi
intruder

from

for this,

available

and correct

(in addition

to others

state

machine
server

client.

If the client

several

[Schneider

from

This

approach,
and

always

know

how

of servers

the client

servers.

many

were

each server

if there

are

not replicated.
or a secure

servers

protocols

Third,

to other

In this

0(n)

parties,
replies,

article

we propose
replication.

must

perform

replies

0(n)

if the
key for

than

possess

a public
cost k

storage.

signed)

replies

the (digitally
e.g., in

many

et al. [1992]),

cryptographic
the client

one as if the service
problems

generality,

to implement
a service
with
n servers
computed
by correct servers, and no other

from
of the

an n-fold

case,

to these

source

must

to

if the set

with

of only

In its full

must

be able

must

of Lampson

a solution

must

information

each client

forward

instead

computaclient

be difficult

authenticate

each client

correct

each

and

may

accepts

the

ability,

First,

in

it to the

and

obtains

is no trustworthy

then

as is the

technique

machine

This

to each server,

a client

the service,

clients—in
service

by an
employs

sends

each server

service.
the

to

corrupted

and

it

and

be designed

to do this

or authentication

n servers,

channel

(see the “push”

store and forward
replicated.

of state

comprise

computations

in cases in which

of the

from
the

the identities

cryptographic

Finally,

more

replicating

servers

can obtain

Second,

additional
service

requires
not

being

then

each of the servers individually.
can change over time or if there

authenticate
which

however,

storage—than

In particto protect

it is to protect

could

to replicating

response
sent
by a majority
of servers,
response if a majority
of servers are correct.
tion,

service

each response

the response

authenticates

risks.

than

One way

the

case,

et al. 1992; Turn

servers

1990]

computes

simplest

resources,

by an intruder

benignly).

987

is not sufficiently

security

1988; Lampson

despite

individually

In the

more

a replicated

failing

approach

each

requires

corruption
and Tygar

To compensate

which

can introduce

or at least

[Herlihy

command.

one server. If this server
must be replicated.

replication

difficult,

servers

server

1986].

to remain
the

environments,

it is often

the

.

using

our approach

must

were

not

a modification
can be used

so that
clients
accept
responses,
provided
that

responses
n > t + b

where t is the maximum
number
of faulty
servers,
and b is the maximum
number
of these faulty servers that behave maliciously.
A novel feature
of our
approach

is that

unlike

“normal”

state

machine

replication

each client possesses exactly one public key for the service
for each server) and can treat the service as a single object
authentication.
plifies
internal

the

This

service

security

enhances

interface
policies

application

for clients,
of the

service

modularity
because
and

and

each client
details

described

above,

(as opposed to one
for the purposes of
significantly

sim-

is insulated

from

of what

or how

many

servers comprise the service. We emphasize
that the client need not be able to
identify
or authenticate
a single server to authenticate
the response
of the
service. Moreover,
the client incurs no additional
cryptographic
computation
or storage costs than if the service were not replicated.
ACM TransactIons on Programming Languages and Systems,Vol. 16, No 3, May 1994

988

M. K. Reiter

.

Even if clients
may

still

accept

and

K. P. Birman

accept only responses
improper

responses

computed

by correct

if an intruder

has

servers,

caused

servers to process improper
requests
or to process requests
order. In this article we also discuss this issue. We focus

clients

the

correct

in an incorrect
on an attack
in

which an intruder
effects and exploits
a violation
of causality
in the sequence
of requests
processed
by the service.
We describe
a method
to avoid this
attack that again requires
that n > t + b and that each client possess only a
single public key for the service.
We have used our techniques
to implement
an authentication
service in a
security

architecture

1992].
fault

In our

for

security

tolerantly

fault-tolerant

systems

architecture,

supports

the

this

[Reiter

1993;

authentication

distribution

Reiter

service

of cryptographic

et al.

securely

keys

for

and
secure

communication
in open networks.
In this
article
we use this
service
to
illustrate
how one of our protocols
can perform
in practice.
The remainder
of this article is structured
as follows. In Section 2 we give a
brief overview
of state machine
replication;
for more detail, the reader should
see Schneider
[1990]. In Section 3 we enumerate
our assumptions
about the
system.
In Section
4 we present
a method
of implementing
services
that
provides
the availability
and integrity
guarantees
outlined
above. In Section
5, we discuss the importance
of maintaining
causality
among client requests
and a method
to counter
an intruder’s
attempts
to exploit
violations
of
causality.

We conclude

2. STATE

MACHINE

A

state

future

and related

work

in Section

6.

REPLICATION
consists

machine

(possibly

and discuss

parameterized)

of a set

of

state

The

commands.

and

variables

state

variables

exports

encode

the

a set

of

state

of

the state machine,
and the commands
transform
that state. Each command
is
implemented
by a deterministic
program
and is executed
atomically
(i.e.,
of the state machine
indivisibly)
with respect to other commands.
A client
invokes
a command
by issuing
a request
to the state machine.
Requests
should be processed
by a state machine
in an order that is consistent
with
Lamport’s
[ 1978b] causality
relation.
That is, requests
from the same client
should be processed in the order they were issued, and if one request
could
have caused another
from a different
client,
then a state machine
should
process

the former
before the latter.
Processing
each request
results
in some
(i.e., output),
which we assume is returned
to the client that issued

response

the request.

Responses

initial

and the sequence

state

State

by

nating

client

1While

the state

replicas

if

all

deliberate)
of n-uersion

design

machine
flaw

programming

TransactIons

with

correct

of one another.

a general

employing

interactions

and

machine

servers

servers
In fact,

affecting

must
it may

method

1 If all

process

satisfy

the

Employing

m Joseph

Languages

machine

servers
same

same
that

of implementing

state

the

be desired

determined

by its

it processes.

many

them.

all of them

as applied

on Programmmg

are completely

of requests
is

simultaneously

state,

ACM

replication

machine

service

of a state

are

sequence

they

need

replicas

Vol

16, No

3. May

same
then

not be identical

to avoid
is similar

[1987].

and Systems,

coordi-

to the

of requests,

not be identical,

nonidentical

and

initialized

specification,

they

a replicated

servers

1994

a (possibly
to the use

How to Securely Replicate Services
all

correct

properly

servers

service,

where

considered,
server

give

the

same

the responses

“properly”

the

depends

service

can retain

response

of the
on the
its

to

servers

any

given

to form

number

and type

availability

request.

the response
of failures

and integrity

By

of the
being

despite

some

failures.

3. THE SYSTEM
Our

will

combining

989

.

system

MODEL

consists

of a set of processes,

n of which

remainder
of which
are clients.
All processes
passing
messages
over a network.
We assume
other
which

are

servers,

and

the

communicate
exclusively
by
nothing
about this network

than what is required
to implement
the communication
our schemes rely; we give specifications
of these protocols

protocols
on
later in this

section.
A

process

specification.
only by the
schemes

is

correct

in

a run

of the

system

A process may fail in an arbitrary
(conjectured)
properties
of the

we employ.

In

order

to capture

if

it

always

(Byzantine)
cryptosystems

the

notions

satisfies

its

manner,
limited
and signature

of a “benign”

failure

versus a purposeful
corruption
by an intruder,
we partition
the faulty
processes into two sets: the honest
processes
and the corrupt
processes.
Formally the only property
that this partitioning
must have is that any process
that
ever suffers
“truly
Byzantine”
failures—i.e.,
failures
that
cannot
be
classified
as crash, omission,
or timing
failures
[Cristian
et al. 1985] —must
be classified

as corrupt.

b, b < t,such that
most b are corrupt.
Although
process
precisely,
tion

processes

as consisting
each

module.

We assume

that

there

server

fail

as a single

of logically
consists

The application

unit,

separate

of a server

known

communication
the application

constants

fail,

is convenient
(see
module
is simply

t and

and of these
to view
Figure
and

at

each

1). More
an applica-

a state

machine

as

m to
module
delivers
a request
m). Requests
are delivered
strictly

i.e., deliver
is not executed
completed.
The state machine

they are delivered.
The
respond(c,
m) by which

it

modules

of a communication
module

described
in Section 2. The communication
that state machine
by executing
deliuer(
sequentially,
deliuer
have

exist

in any system run, at most t servers
We assume that n > t + b.

until
all previous
processes requests

module
module

executions
of
in the order

also implements
a primitive
can send a response
m to a

client
c. This response
m is of the form
(c, m’, m“ ), where
this response
resulted
from processing
the request,
m’ and m“ are the “contents”
of the
response. (Alternatively,
the response could include
only an identifier
for the
request,
instead
of the entire
request.)
For simplicity,
we assume that each
request

contains

information

sufficient

for

each

server

whatever
degree of certainty
the application
requires)
the
it, and that the resulting
response is sent to that client.

to

determine

client

that

(to
issued

Servers’
communication
modules
make use of network
communication
to
coordinate
request
deliveries
and to communicate
responses
to clients.
One
type of network
communication
is of particular
interest
in this article:
we
assume
that
the network
supports
an authenticated
broadcast
primitive
ACM Transactions

on Programming

Languages

and Systems,

Vol. 16, No. 3, May 1994.

990

M. K. Reiter and K. P. Birman

.

Application

Application

Module

Module

~- ----- ~cc!!;t-;)-- -n?:-’(m)
I

Communication

[

h
receive((s,

Communication

Module

h
m))

v

t

Network

Network

(a) Server

(b) Client
Fig.

1.

Structure

of processes

beast(m)
message

by which the communication
module
of a server
communication
(s, m ) to all servers. A server’s

message

(s, m),

with

contents

ing receiue((s,
m)). Messages
fies the following
specification.
—Receipt

honest

If

Validity:

receiue((s,

—Receipt

Module

h
.,

beast(m)

m))

Authentication:
server

a

is executed
executes

and (apparently)

m

are received

correct

server

at all correct

If server

s

server

s, by execut-

to a protocol

executes

a
a

that

bcast(

m ),

satis-

then

servers.

s is correct

receiue((s,

from

according

s can broadcast
module
receives

m))

or honest,

only

if

s

then

a correct

previously

or

executed

beast(m).

A client
also consists
of an application
module
and a communication
module.
The application
module
of a client is some client program
that can
m to the service by executing
request(m).
Processes’ commuissue a request
broadcast
protocol by which requests
nication
modules
implement
an atomic
are delivered
to servers’ application
satisfies
the following
specification.
—Delivery

Validity:

is executed

If a correct

at all correct

modules.

client

executes

This

atomic

request(m),

broadcast

then

protocol

deliver(m)

servers.

m) is the ith execution
of deliver
at a correct or
—Delivery
Order: If deliuer(
m) is the ith execution
of deliver
at all correct
honest server, then deliuer(
servers. That is, all correct servers deliver
the same sequence of requests,
and the sequence of requests
delivered
by an honest server is a prefix
of
the sequence of requests
delivered
by a correct server.

Assuming
implies
that

that each server is initialized
all correct and honest servers

to the same state, Delivery
Order
will produce the same response (or

no response)
to a given request.
Options
for implementing
atomic broadcast
are discussed
in Section 6.1.1. Here we simply
note that there already
exist
protocols
in the literature
that satisfy this specification
in various models and
Our protocols
do not rely on any bounds on
for various
definitions
of honest.
message transmission
times or the execution
speeds of processes, and so the
ACM Transactions on Programming Languages and Systems,Vol. 16, No. 3. May 1994.

How to Securely Replicate Services
Table I.

Summary

991

.

of Notation

Notation

Definition

system parameters
n

total number of servers
maximum number of faulty servers in any system run
I maximum number of corrupt servers in any system run
(the corrupt servers are a s;bset of the faulty servers; so, b < t)

I

t
b

server routines
deliver(m)
respand(c,

delivers client request m to application

receive((s,

app~cation

m))

bcas~(m)
client routines
accept(m)

accepts response m for application
issues request m to service

request(m)

only

such

bounds

module

module responds to c with m
receives (authenticated)
broadcast (s, m)
when executed at s, broadcasts s, m to servers

m)

required

for our

particular
atomic broadcast
A client’s
communication

results,

protocol
module

module

if any,

used.
accepts

are those

a response

required

m for its

by the

application

module by executing
accept(m).
Responses are accepted strictly
sequentially;
i.e., accept
is not executed
until
all previous
executions
of accept
have
completed.
The protocol
by which
satisfies
the following
property.
—Acceptance
Validity:
If
correct, then c executes
4. PRESERVING

responses

a correct
server
accept ( m).

lNTEGRITy

are

communicated

executes

respond(c,

to

m)

clients

and

c is

AND AVAILABILITY

Recall from Section 1 that our first goal is to ensure that each client accepts a
response computed
by a correct server, and no other responses,
for each of its
requests.
We satisfy these requirements
by replacing
the respond(c,
m) and
accept (m) routines
of servers
respond (c, m) and accept’(m),

and clients, respectively,
with two new routines,
that will ensure this. Thus, the new structures

of processes
will be as pictured
in Figure
2. While
we have replaced
the
routine
with
respond’
at the interface
provided
to the application
respond
module
respond

of each server,
respond
will
to send a response to a client.

implementation

of accept’

to accept

and

—Integrity:

A correct or honest client
executes respond (c, m).

—Availability:
accept((c,
4.1 Threshold

routines

will

a message

respond

server

accept’

If a correct
client
m, m’)) for some m’.
Signature

be used
Similarly,

ensure

that

implementation
of
will be used in the

at a client.
the following

c executes

c executes

in the
accept

accept(m)
request(m),

As desired,

the

hold.
only

if a correct

then

c executes

Schemes

signature
The respond’
routine
at the servers will employ a (k, n)-threshold
scheme. A (k, n)-threshold
signature
scheme
is, informally,
a method
of
ACM

Transactions

on Programming

Languages

and Systems,

Vol. 16, No, 3, May 1994

992

.

M K. Relter and K. P. Blrman

Application
----

Application

Module
----

del,ver(m)
.
.
Co:m::l::t::t::v)

.

-

.

::2:!:t::~::~

bca-st(m)

A

A
receive((s, m))

Module

--h

i
Network

Network
(a) Server

(b) CLient

1
Fig. 2.

New structure

of processes.

generating
a public key and n shares
of the corresponding
private key in such
a way that for any message m, each share can be used to produce
a partial
from m, where any k of these partial
results
can be combined
into a
result
signature
for m that can be verified
with the public key. Moreover,
knowledge of k shares

should

be necessary

to sign

private
key it should be computationally
k partial
results
for m,
for m without
without the corresponding
share, or (iii)
k other shares.
without
Crytanalytic
attacks

on

threshold

m, in the sense that

infeasible
(ii)

compute

compute

signature

without

to (i) create
a partial

a share
schemes

the

a signature
result

or the

private

differ

from

for

m

key
those

against conventional
signature
schemes in that the cryptanalyst
may possess
some number
of shares and be able to acquire
partial
results,
in addition
to
message\
signature
pairs. For our purposes,
we will say, informally,
that a
the following
proper(k, n)-threshold
signature
scheme is secure if it satisfies
ties.
results for various
(1) Possession
of only k – 1 or fewer shares and of partial
messages does not facilitate
signing
new messages. That is, if a possessor
of such information
can sign a new message,
message
without
knowledge
of any shares
messages.
This property,
which
is formalized
[19921, says
conventional

that
the
signature

then it could also sign that
or partial
results
for any
in Frankel
and Desmedt

threshold
signature
scheme
scheme on which it is built.

is

as secure

as the

(2) The conventional
signature
scheme
on which
the threshold
signature
scheme is built prevents
selective forgery
under known-signature
attacks.
That is, a cryptanalyst
cannot manage to sign messages of its choice even
though it can see signatures
for various
other messages (not of its choice).
routine
is not dependent
on any particular
implementation
of
Our respond’
a (k, n)-threshold
signature
scheme. For concreteness,
however,
we describe
respond
in terms of an implementation
proposed
in Frankel
and Desmedt
[1992] (which
is a slight variation
of one proposed
in Desmedt
and Frankel
[1992]). That implementation
begins with an RSA [Rivest et al. 1978] public
ACM

Transactmns

on Programmmg

Languages

and Systems,

Vol

16, No 3, May

1994

How to Securely Replicate Services
key (e, N)
the

create
{K,}l

function

e from

positive

key d, where

and private

Carmichael

d. That

integer

such

N is the product

A is used
ed -

1 mod A(N),
= 1 mod N

~, ~ ~ are generated

from

totient

where
for

d in such a way

993

of two safe primes,

of Euler’s

x ‘(~)

is,
that

in place

.

all

and

function

~ to

A(N)

is the

smallest

x = Z;.

The

n shares

for any set T c {1,...,

that

of size k, Z ,. ~(K, “p,,~) - d – 1 mod A(N), where the integers
fixed a priori
and public.
(Each of the integers
p,, ~ for all
computed
from a fixed set of n integers,
each of binary
O(n) integer
multiplications
and additions.)
By defining

n}

{p,, T},. ~ are
i and T are

length
O(log n), with
the ith partial
result

for a message m to be am,, - m~’ mod N, it follows that for any T c {1, ....n}
ofsizek,
A~~=
m-~
,. T( am,, )P’, T mod N is the proper RSA signature
for
m, i.e., md mod N. Variations
of this scheme have been proved to be as secure
as RSA, in the sense of property
1 above [Frankel
and Desmedt
1992].
For reasons
of security
and efficiency,
it is often preferable
to sign a
message

digest

A message
for

any

of a message,

digest

input

infeasible

function
m

can

to produce

to produce

as opposed

be

computed

two distinct

any input

to the message

f has the properties

m such

that

efficiently,

inputs

that

but

m and

f(m)

itself

[Denning

the message
it

is

m’ such that

f(m)

computationally
f(m)

= f( m’ ) or

= D for some prespecified

digest D. Several efficient
implementations
been proposed
(e.g., Rivest
[1991]).
We
function.

1984].

digest

message

of message digest functions
have
henceforth
use f to denote
such a

4.2 The Protocol
Suppose

that

created
that

a public

as above,

for all

process
discuss

with

key

(e, N)

i < n, the

i, 1<

and

the threshold
ith

corresponding

parameter

server

shares

k = b +

{K,}l

~, ~ ~ are

1, and distributed

s, is the sole possessor

of K,

so

and any

can reliably
obtain
(e, N), the public
key of the service. We do not
methods
for distributing
this information,
although
we note that all

public-key
systems require
similar
steps. The (information
for computing
the)
integers
pt T for all i and T can be “hardwired”
into the servers. Then, the
respond’ (c, ‘m ) and accept’(m)
routines
are implemented
as follows.
Routine

respond’

(c, m) at server

s,:

(1) Execute
bcast(( f(m), a~t~),, )),
partial
result for f(m).

where

(2) Wait

{{ s~, ( f(m),

until

received
ture

a set

of messages

2 of

respond.

Delivery

a~ ))}~ ~ T,

mod N
ITI = k,

has

A ~f~~,T = f(m)”
~ ~. T( aj)P~,T mod N is a valid
(i.e., such that (A~(~), T)’ - f(m) mod N).2

2Here we assume that messages can be received

respond’

- (f(m))~’

such that

for f(m)

for example,

a~(~j,,

that locks required
More generally,

and
Validity

accept’

does

or Order,
ACM

not

the execution

of respond’.

This

St’s
been

signa-

implies,

to receive messages must not be kept by threads
waiting
in step
we assume
that the replacement
of respond
and accept
with
result

or Acceptance

Transactions

during

is

in

the

violation

Validity

on Programming

(with

of Receipt
accept

Langaages

Validity

replaced

and Systems,

or Authentication,

by accept’).
Vol. 16, No. 3, May 1994.

994

M. K. Reiter and K, P. Birman

.

(3) Execute

respond(c,

Routine

( m,

Af(mj,

czccept’( m) at client

(1) If m is not of the form

~ )).

c:

((c,

m’, m“ ), S ), then

(2) If accept(( c, m’, m’”)) for some
return
to the calling
routine.

m’”

was

return

to the calling

previously

executed

(i.e., if
(3) If S is a valid
signature
for f’((c, m’, m“))
mod lV), then execute
a,ccept(( c, m’, m“ )) and return
tine

only

THEOREM

satisfies

server

Suppose

at most
produces

computes,
responses
useless,
improper

scheme

signature

is secure,

that

the

threshold

signature

scheme

is

secure.

Then,

b < k servers are corrupt
and because each correct or honest
partial
results
only for message digests of responses
that it

or honest

must

This protocol

2.

PROOF.

client

have been computed

satisfies

at all correct

(by Acceptance
client

servers

m) at a correct

Validity
will

accept

❑

server.

1 = k correct

b +

servers

broadcast

message
digest
of) each response.
Thus,
by
server
eventually
receives
k correct
partial

results for each of its responses,
and so each correct
each of its responses.
Since each request
issued
of respond(c,

by a correct

Availability,

n > t + b, at least

Because

their
partial
results
for (the
Receipt
Validity,
each correct

4.3

this protocol

message digest values).
So, the corrupt
servers cannot generate
an
response that a client will accept, and any response that is accepted

THEOREM

correct

then

corrupt
servers can generate
signatures
only for message digests of
computed
by correct
servers (and possibly
for other, presumably

by a correct

delivered

S’ = f((c, m’, m“))
to the calling
rou-

it has completed.

If the threshold

1.

c, then

Integrity.

PROOF.
because

after

routine.

at

(by Delivery
server

results

server can correctly
by a correct
client

Validity),

and since

in an execution

with

an execution

of accept’(m)

accept replaced
by accept’),
a response for each of its requests.

sign
c is

it follows

at

that

c

a

❑

Discussion

In theory, the
the respond’
receives until
server must
ceived

results,

(from

most computationally
expensive
part of this protocol is step 2 of
routine,
in which the server sorts through
the partial
results
it
it finds a T of size k such that A ~(m),T is a valid signature.
The
results
reexamine
at most the first
k + b = 2 b + 1 partial
k + b

because

in

unique

servers),

k + b partial

and

results

at most
are

~~b

()

at least

k

subsets
correct

of partial
ones. While

this search is exponential
in b in the worst case and could be costly if b is
large and the actual number
of corrupt
servers is close to b, in most systems
number
of corrupt
servers will typically
be
n (and thus b) and the actual
small. (For example,
our experience
with the Isis system [Birman
et al. 1991]
suggests that fault-tolerant
services are sometimes
implemented
by three to
five servers, but rarely
more.) Thus, while we are pursuing
optimizations
to
ACM

TransactIons

on Programming

Languages

and Systems,

Vol. 16, No

3, May

1994.

l-low to Securely Replicate Services
make

this

them

to be primarily

search

In terms
ment

less costly

of communication

of respond

executed
client

with

communication
request
by the
executions

of beast),

only

and the

needs to obtain

servers.

The broadcast

a protocol

entire

run

systems
that

processes,

partial

results

of the

only

that

this

results

on behalf

request.

could

Receipt
allow

Validity.

these

of correct

for the

However,

or honest

when

further

per

and its share

of the

key of the service

request.

While

they

are

private

and must

additional
in

ticate

each

proach

server

is that

of our services

Each

verify

step

client

to scale to very

large

needs

signed

responses

accept’

complicating

for server

systems

may

many

for

the

only

the

response

arrive

at the

performing
clients

weakness

burden,

with

signed)

where

practical

informa-

key

to know

without

replication,

primary

burden

client

one (correctly

2 of

the

to the

only

on them.
state machine

individually,

by trading

addition

key.

correctly

discarded

cryptographic
computation
In comparison
to “normal”

in

are

incorrect

public

the

common
there

p,, *’s),

to compute

set of

by employing

to disseminate

servers,

the

to that

processes)

processes

for each

Additionally,
only

be optimized

are no corrupt

execu-

be optimized

tion

client,

a

of three

response
could

need to be broadcast

there

only
would

signed

signature.
of public

public

when

( n concurrent

communication

to any given

would

of partial

responses

results that form a correct
must know 0( n log n) bits

service

can be

consists

each server’s search for partial
In this protocol,
each server
order

replace-

which

begins

a response

one correctly
this

respond

(i.e., when

satisfies

corrupt

(in

we view

the

of beast,

protocol

it accepts

to be satisfied,

for the response

case in most

the

sending

t + 1 servers

results

in a failure-free

in n executions

and ends when

for Availability

partial

6.1.2),

“phases”
that
must be executed
roughly
sequentially:
the
client,
the dissemination
of partial
results
(n concurrent

tions of respond).
Because a client
by having

results

Therefore,

a request

of b (see Section

995

interest.

complexity,

respond

concurrently.

issues

request

as a function

of theoretical

.

authen-

of our

we limit
clients.

any

ap-

the ability

Our

approach

was motivated
primarily
by the need for a highly secure and available
service
—the authentication
service of Reiter [1993, Ch. 3] —where
alternatives
for
dealing
with issues of scale previously
anyway.3
In this case, our approach
insulating
policies
client

clients
of the

processors

the

service.

with

similar

3Having

from

service

Our

the

implementation

(e.g., the value

and the latencies
approach

and

protocols

that

be an attractive

be necessary
benefits
by

internal

security

overhead

use the responses

alternative

for

on
of

systems

requirements.

one authentication

employed

details

of b), and by minimizing

of client

should

service

for a very

and there may not be a single authority
Approaches
using multiple
authentication
been

existed and would often
has yielded
substantial

in systems

to remedy

large

system

can be administratively

impractical,

trusted
by everyone
to protect
it [Lampson
et al. 1992].
services
(e.g., one per administrative
domain)
have

these

problems

(e.g., Lampson,

et al. [1992]

and

Steiner

et

al. [1988]).
ACM

Transactions

on Programming

Languages

and Systems,

Vol. 16, No. 3, May 1994.

996

M, K, Reiter and K, P. Birman

.

4.4

Performance:

As

an example

this

section

An Example
of how

we

the

protocol

discuss

the

of Section

4.2 might

performance

of

the

perform

in practice,

public-key

in

authentication

service of Reiter [ 1993]. This service was a primary
motivation
for this work
and has been implemented
using
the protocol
of Section
4.2. It has been
constructed
as part of a larger
effort to integrate
mechanisms
into Isis, a
system
for building
fault-tolerant
applications
[Birman
et al. 1991]. The
security
architecture
we have developed
is presented
in Reiter
[1993]
and
Reiter et al. [1992].
In our security
authority

architecture,

as to which

public

the

authentication

key belongs

service

to which

is

principal

the

trusted

computer,

(e.g.,

certificates
user). To exercise this authority,
the service produces
public-key
for principals.
Each certificate
contains
a principal’s
identifier
and the public

key

for that

principal

(among

other

things),

bound

together

with

the

signa-

ture of the authentication
service. Because requests
for certificates
commute,
clients issue requests
to the service with an unordered
multicast
(i.e., Delivery Order is not enforced).
The performance
of our prototype
service is illustrated
in part (a) of Figure
3. The line indicates
the mean response
time in seconds as a function
of n,
the number
of servers. For each n, we assumed that t = b = \(n – 1)/2]. We
have illustrated
the curve for up to nine servers, although
we expect that few
services will be implemented
by more than five, as mentioned
In these tests the RSA modulus
iV was 512 bits. These tests

in Section 4.3.
were executed

between

33 MHz

user processes

over SunOS

4.1.1 on moderately

loaded

Spare

ELC workstations.
The workstations
spanned
two 10 Mbit/s
ethernets
connected by a gateway.
Each data point is the mean of 40 consecutive
trials.
The cost of performing
exponentiation
modulo
iV is the direct cause of the
poor response
times in part (a) of Figure
3 and, in general,
is the limiting
factor in the performance
of our authentication
service. Exponentiation
modU1O N
and

is required

to construct

k exponentiations

a partial

modulo

N (but

result
with

from

a share

and

a message,

much

smaller

than

exponents

N)

are used to construct
a signature
from k partial
results.
Moreover,
none
these modular
exponentiations
lend themselves
to well-known
optimizations
using

the

Chinese

Remainder

since a server cannot
Figure
3 reflects
the

so ftware,4
and we expect
will generally
be required
with

4In

the

these

RSAREF
developed
faster
rity,

protocol

tests
toolkit,
to

support

software

the

4.2.

exponenti

Even

of charge

privacy-enhanced
However,
ation

with

Data

electronic

of modular

would

most

mail,

not

Inc

The

primary

provided

Transactions

on Programming

Languages

(a) of
in

of which
factor

and Systems,

with
toolkit

communication,
from

RSA

the
was
and

Data

Secu-

we are aware,

the cost

performance

in our

limitmg

service.
ACM

[ 1993]),

hardware

RSAREF

interprocess
are available

Implementation

to be the

available

exponentiation

Security,

exponentiation

any software
continue

Vuillemin

of N. Part
exponentiations

presently

of modular

by RSA

and

the factorization
these modular

support
for modular
exponentiation
to achieve satisfactory
performance

with

C implementation

free

implementations

Inc. and others.

of modular

used

licensed

(see Shand

that hardware
at the servers

of Section

we

Theorem

be allowed
to know
cost of performing

of

Vol. 16, No. 3, May

1994,

How to Securely Replicate Services
3.8-

90

3.7-

80

3.6-

70

.

997

1
i

‘Si!:
se

3.5S

3.43.33.2-

u-

3“’~

20-

3

5

7

I
3

9

I
5

I
7

‘n

n

(b)

(a)
Fig. 3.

Response

times

[Brickell
1990], the cost of modular
primary
factor limiting
performance
promise,
e.g., modular
exponentiation
in a few milliseconds
or less [Orup
Vuillemin
1993], will make this
In our prototype
implementation
invested

in hardware

compensate
tecture
the

so that

Nevertheless,
with

such

off the
to gain

hardware,

time,

with
critical

insight

the
path

into

we have

service.

exponentiation
will continue
to be the
in our protocol.
However,
advances that
with a 512-bit
exponent
and modulus
et al. 1991; Sedlack
1988; Shand
and

modular

response

interactions

of an example

less and less the case.
of the authentication

to support

for its poor

background,

1
9

the

tested

we have
of any

potential

protocol

always

To

archioccur

in

or computation.

performance

performance

servers.

our security

service

other

we have not

at the

designed

authentication

the

service,

exponentiation

of our

of our

service

prototype

with

the (software)
modular
exponentiation
routines
removed
from the servers.
This is obviously
an optimistic
simulation
of hardware
performance.
However, in light of the recent advances in modular
exponentiation
hardware
just
mentioned,
these tests could be indicative
of the potential
performance
of our
service.
The results

of these

tests

are illustrated

in part

(b) of Figure

3. The

solid

line indicates
the mean service response time in milliseconds
as a function
of
n. For comparison
purposes,
we also modified
our authentication
service to
simulate
its performance
if it used “normal”
state machine
replication,
where
each server
client,
and

individually
the client

computes,
authenticates

digitally
signs, and sends its reply to the
h of these replies.
(Again,
all modular

exponentiations
were removed
from the servers.)
The performance
of this
approach
is shown by the dashed line.
As illustrated
in part (b) of Figure
3, state machine
replication
performed
slightly
better than our approach
in most cases. This is due to the round of
server communication
in our approach
to disseminate
partial
results.
In the
ACM

Transactions

on Programming

Languages

and Systems,

Vol. 16, No 3, May 1994

998
tests

M, K Reiter and K. P. Blrman

.

of Figure

3, partial

results

were

communicated

between

authenticated
point-to-point
channels;
the cryptographic
for authentication
were implemented
entirely
in software.
tion of hardware
bly be optimized

for modular
by exploiting

exponentiation,
this hardware.

servers

using

mechanisms
used
Given our assump-

this dissemination
could possiFor instance,
each server could

be initialized
with its own RSA private
key and the public keys of the other
servers, and partial
results
could be authenticated
using RSA digital
signatures. Moreover,
this opens the possibility
of using hardware
multicast
to
disseminate
partial
results,
since the same digitally
signed
partial
result
could

be multicast

While

the

to all servers

increase

at once.

in response

times

as a function

stems from server communication,
the increase
results from the client having to verify multiple

of n in our

approach

for state machine
replication
signatures.
In these tests, all

public RSA exponents
were set to three (i.e., e = 3) for maximum
efficiency
in
verifying
signatures.
With the RSA software
we employed,
signature
verification then cost approximately
10 ms per verification.
This increased
cost on
the client
processor
gives us the opportunity
to make an important
point:
while the response time of our service is slightly
worse, the client processor is
free for all but the time
required
to make
a request
and to verify
one
signature.
in which

In settings
equipping

prohibitively
It is risky

in which client processors
all clients
with
modular

expensive,
to conclude

this

could

too much

the single most important
factor
normal
state machine
replication,

tend to be heavily
loaded
exponentiation
hardware

be an important
from

part

and
is

feature.

(b) of Figure

3. We reiterate

that

in the performance
of both our approach
and
namely,
the speed of modular
exponentia-

tion at the servers, was removed from these
other factors—including
the optimizations

tests. Moreover,
there
on the dissemination

are several
of partial

results
described
above and the existence
of faster software
implementations
of signature
verification
with
e = 3 (which
will cause the dashed curve to
flatten
somewhat) —that
could impact
these tests. Additionally,
the service
used in these tests is atypical
in that it does not require
that client requests
be delivered
by an atomic broadcast
protocol.
(However,
since
cast is generally
a requirement
of both our approach
and
machine
replication,
the impact
on both should be the same.)

atomic
normal

broadstate

Nevertheless,
part (b) of Figure 3 does indicate
that with efficient
hardware
support
for modular
exponentiation
at the servers, the protocol
of Section 4.2
may provide
acceptable
response
times
for many
services.
This, combined
with the additional
features
of our scheme (e.g., insulating
clients
from the
service implementation
and removing
burden
from client
processors),
supports the hypothesis
that our approach
can be a reasonable
alternative
to
normal
state machine
replication
in some situations.

5. PRESERVING

INPUT

CAUSALITY

One guarantee
provided
in the previous
section is that any response accepted
at a correct
or honest
client
was computed
by a correct
server. Even the
output
of a correct server, though,
may not reflect the way things “should
be”
ACM

Transactions

on Programming

Languages

and Systems,

VOI 16, No 3, May

1994

How to Securely Replicate Services

if

an intruder

process

has

requests

from

a correct

and

to enforce

because

caused

server

computed

by corrupt

to process

clients

state
cannot

ensuring

state

variables

variables

that

be trusted.

999

requests
proper

to authenticate

on what

from

improper

In general,

mechanisms

controls

cating
client
requests
Lampson
et al. [1992])
in

service
order.

requires

access

responses

or indirectly)

the

in an incorrect

.

client

requests

clients

can

can be written

Approaches

or to

responses
write,

(directly

for authenti-

and enforcing
access controls
are well
and will not be discussed further
here.

known

(e.g.,

In this section we address the issue of ensuring
that requests
are delivered
a correct
order by correct
and honest
servers.
Because
we assume
an

atomic
selves
order
ing

broadcast
only with

protocol
to disseminate
client
requests,
we concern
ourthe requirement
that correct servers deliver
requests
in an

consistent

with

to preserve

refrain

from

service

and

causality

a causal
communicating

the

time

(see Section

order

among

between

at which

the

2). A common

client
the

request

requests

time

it

method
is for

issues

is delivered

of attempt-

each

client

a request
at some

to

to the

honest

or

correct server [Schneider
1990]. While
this suffices to ensure that requests
from the same client are delivered
in the order issued, this does not suffice to
ensure

a causal

delivery

order

for

all

requests.

In

particular,

consider

a correct
a corrupt

corrupt
client
ship between

subsequently
issues a request,
then there is a causal relationthe two requests.
However,
it is not clear how this relationship

can be detected
To illustrate

client issues a request to the service, and after
server
sends a message
to a corrupt
client.

the

case in which
the request,

by correct
why this

servers.
may be important,

we

borrow

an

seeing
If the

example

from

Reiter et al. [1992]: suppose that the service is a trading
service that trades
stocks, and that a client issues a request to purchase
shares of stock through
this

service.

collude

After

with

discovering

a corrupt

client

same stock to the service.
that
of the correct
client,
for

the

stock

and

raise

the intended

purchase,

as described

above

If the correct
this request
the

price

a corrupt

to issue

server

a request

could
for

the

servers deliver
this request
before
may adjust
the apparent
demand

offered

to

the

correct

client.

Thus,

by

allowing
the causally
subsequent
request of the corrupt
client to be delivered
before the request
of the correct client, a type of “insider
trading”
may occur.
Moreover,
access controls
alone cannot
naturally
avoid this problem,
since
the intent
In the

is that any client can request to purchase
stock
rest of this
section,
we present
new routines

deliver’(m)
these are

that replace
used with the

at any time.
request’(m)

request(m)
and deliver,
respectively.
respond’
and accept’ routines
of Section

and

Thus, if
4.2, pro-

cesses would be structured
as in Figare 4. These new routines
protect clients
from the type of attack described
above, in the sense that any request based
m can be
on information
obtained
from a correct or honest client’s
request
delivered
at correct or honest
servers only after m. As before, we will use
deliuer
to deliver a request in our implementation
of deliver’,
and we will use
request to issue a request in request’.
In the implementation
of request’(m),
the client
c encrypts
m under the
public key of the service before issuing
the request to the service. Then, c is

ACM

Transactions

on Programming

Languages

and Systems,

Vol

16, No. 3, May 1994

1000

M. K, Reiter and K, P. Birman

.

Application
----

Module

Application

----

deh

ve#

(m

)
.

.

co:m:i:~:r:v)
A
4
receive((s,

beast(m)

provided

h

Network

Network

(a) Server

(b) Client

the following

that

this

New structure

guarantee

guarantee

of processes.

if it is correct

prevents

or honest.

the aforementioned

If deliver
is executed
at a correct
deliuer( m) has not yet been executed
at s, then
was decrypted
anywhere
(other than c).

—Causality:

To guarantee
must

also

that

ensure

that

servers’
client

the

specification
of atomic
quest
replaced
by request’)

5.1 Threshold

states

should

or honest server s when
m’ was issued before m

consistent,

request’

and

deliuer’

requests

continue
to be delivered
according
that Delivery
Validity
(with
broadcast—i.e.,
and Delivery

Order

still

to
re-

hold.

routine

at the servers will employ
a (k, n)-threshold
cryptosyscryptosystem
is, informally,
a method
of generating
a
n shares
of the corresponding
private
key in such a way that

Our

deliver’

A (k, n )-threshold
key and

for any message m encrypted
under
produce
a partial
result
from the

partial

remain

The reader

problem.5

Cryptosystems

tem.

public

-

i

Fig. 4,

verify

,.
C::f!xt:::!:::)-

-

m))

Module

the public
ciphertext

key, each share can be used to
any k of these
of m, where

results
can be combined
to decrypt
m. Moreover,
knowledge
of k
should
be necessary
to decrypt
m, in the sense that
without
the
k
key it should be computationally
infeasible
to (i) decrypt
m without

shares
private

partial
results
for m, (ii) compute
a partial
result
for m without
the correk other
sponding
share, or (iii) compute
a share or the private
key without
shares.
As with threshold
signature
schemes, cryptanalytic
attacks against threshold cryptosystems
differ
from those against
conventional
public-key
cryptosystems
in that
they may involve
the use of partial
results
and some
number
of shares, in addition
to plaintext/ciphertext
pairs. For our purposes,

5We do

not consider

malteabdity

traffic

analysis

of the cryptosystem

ACM Transactions

on Programmmg

attacks

[Voydock

and Kent

1983]

or attacks

that

[Dolev et al. 1991],
Languages and Systems, Vol. 16, No 3, May 1994.

exploit

the

How to Securely Replicate Services
we will

say,

satisfies

the following

informally,

(1) Possession

of only

ciphertexts

that

a (k, n)-threshold

cryptosystem

.

1001

is secure

if it

properties.
k – 1 or fewer

does not

facilitate

shares

and of partial

decrypting

new

results

ciphertexts.

for various
That

is, if a

possessor of such information
can decrypt
a new ciphertext,
then it could
also decrypt
that ciphertext
without
knowledge
of any shares or partial
results for any ciphertexts.
This property,
which is formalized
in Frankel
and Desmedt
[1992], says that the threshold
cryptosystem
is as secure as
the conventional

cryptosystem

on which

it is built.

(2) The conventional
cryptosystem
on which
the threshold
cryptosystem
is
built
is resistant
to known-plaintext
attacks.
That is, the cryptanalyst
cannot manage
to decrypt
given ciphertexts
even though
it can see the
plaintext
corresponding
to various
other ciphertexts
(but not corresponding to ciphertexts

of its

as would

choice,

be possible

in a chosen-ciphertext

attack).
As we will see in Section 5.2, we would actually
prefer a threshold
cryptosystem that is based on a conventional
cryptosystem
able to tolerate
chosen
ciphertext
attacks.
However,
the above definition
is in accordance
with the
security
of all implementations
of threshold
cryptosystems
thus far proposed,
in the sense that all proposed
implementations
are based on conventional
cryptosystems
that are known to be vulnerable
to chosen-ciphertext
attacks.
Because
the acts of signing
a message
and decrypting
a message
are
operationally

identical

implementation
from

the

in the

(k, n)-threshold

sages would be encrypted
and the ith partial
result
be defined

RSA

signature

of a (k, n)-threshold

precisely

scheme

cryptosystem

signature

scheme

and

cryptosystem,

can be obtained

described

in

Section

one
directly

4.1. Mes-

under the public key (e, IV) in the usual manner,
for an encrypted
message m = (m’)’ mod IV would

as in Section

4. l—i.e.,

am,, - mK’

mod IV. Then,

m’

=

IV for any T of size k. Other
implementati~n~ of threshold
cryptosystems
have been proposed,
based on both the RSA
and EIGamal
[1985]
cryptosystems
[Desmedt
and Frankel
1990; Laih and
Ham
1991].

A

=m.n

,. T( an,,

)PZ, T mod

5.2 The Protocol
Suppose that we are using the RSA threshold
cryptosystem
described
above
and that we have the initial
conditions
assumed in Section 4.2: the ith server
s, is secretly given sole possession
of K,; the cryptosystem
threshold
parameobtain
the public
key (e, IV) of the
ter k = b + 1; any process can reliably
service; and all servers know (a priori)
p,, T for all i and T. The basic idea of
our protocol
is that each client
encrypts
each of its requests
m with
the
public
key of the service, in an
decrypt it. Then, each correct or
partial
result for the ciphertext
is fixed locally. In this way, once
the ciphertext

of m, the delivery
ACM

Transactions

attempt
to force k servers to cooperate
honest server refrains
from broadcasting
of m until the delivery
sequence through
results
a corrupt
server collects k partial
sequence

on Programming

through

Languages

m is fixed
and Systems,

to
its
m
for

at some correct

Vol. 16, No. 3, May 1994.

1002

.

M. K. Reiter and K. P. Birman

or honest
server,
and thus at all correct
servers,
and no requests
can be
placed before m in the delivery sequence at correct or honest servers.
k partial
This protocol
preserves
Causality
only if each server requires
of m to decrypt
that ciphertext.
Even under the
results for the ciphertext
assumption
that this cryptosystem
is secure, however,
this unfortunately
is
the case with this or any implementation
of a (k, n)-threshold
cryptosystem proposed thus far. The problem is that our protocol
as described
above
allows
a corrupt
server to mount
chosen-ciphertext
attacks,
against
which
not

neither

the RSA

nor the EIGamal

cryptosystem

cryptosystem
based on them) is resistant.
In
see at any time how any ciphertext
m of its
requesting
that a corrupt
client issue m as
to the service. The corrupt
server can then

(nor

any proposed

threshold

our setting,
a corrupt
server can
choosing is decrypted,
by simply
an apparently
legitimate
request
results
for m to
collect k partial

m decrypts.
see the plaintext
to which
Methods
of using chosen-ciphertext
attacks
against
the RSA and EIGamal
cryptosystems
are well known. Here we present one method,
originally
due to
Moore (see Denning
[1984]),
by which a corrupt
server can decrypt
the RSA
m = (m’)’
mod N of a client’s
ciphertext
results
for m.
receive k partial

(1) The corrupt

server chooses
i.e., x = yd mod N.

(2) Via

a corrupt

client,

the

an arbitrary

corrupt

server

request

x and
issues

m’

without

computes
the

request

for

ym

waiting

y - x’
ym

to

mod N;

mod N to

the service.
(3) The corrupt server
(ym)~
mod N.
(4) The corrupt

server

collects
computes

x-’(ym)~

partial

k

x-1

=y-dydmd

results

= y-d

= md

(NB: If x does not have an inverse
factor N and break the cryptosystem,
of N.)

mod N

and

forms

mod N, and then

= (m’)ed

= m’

mod N.

mod N, then the corrupt
server can
because gcd( x, N) is a prime factor

Similar
attacks
are possible
with the threshold
cryptosystems
described
in
Desmedt
and Frankel
[1990] and Laih and Ham [1991].
Ideally,
we would like to find a threshold
cryptosystem
based on a conventional
public-key
cryptosystem
that is tolerant
of chosen-ciphertext
attacks.
To our knowledge,
however,
no such threshold
cryptosystem
has been proposed, and even conventional
public-key
cryptosystems
that are tolerant
of
such attacks (e.g., Dolev et al. [1991]) are impractical.
Therefore,
such attacks
A simple way to prevent these attacks is to authenticate
must be preuented.
client requests
and have each client use a separate
public encryption
key for
the service. This would
prevent
chosen-ciphertext
attacks
against
the keys
and ciphertexts
of correct
and honest
clients,
because
a request
from
a
corrupt
client would be decrypted
using the shares of the key for that client,
and not a correct
or honest
one. However,
this approach
complicates
key
ACM

Transactions

on Programming

Languages

and Systems,

Vol

16, No, 3, May

1994

How to Securely
management,

requires

and requires

that

An alternative
text

attacks

more

clients

at the servers

Services

to store

1003

.

a share

per client,

be authenticated.

method,

using

storage

Replicate

which

we adopt

a cryptographic

here,

is to prevent

technique

introduced

chosen-cipherin

[1994]. With this approach
each server can determine
(with
ity), prior to creating
its partial
result for a request,
whether

Lim

and

Lee

a high probabilthe request was

properly
created from a plaintext.
If not, then the server discards the request
and does not create its partial
result for the ciphertext.
In the technique
of Lim and Lee [1994] as applied
to RSA, the ciphertext
for a message
m consists
of three
parts.
The first
part
ml is the RSA
ciphertext
of a secret, random
seed q to a cryptographically
strong pseudorandom
bit generator
G; i.e., ml = q e mod N where e and N are the public
RSA exponent
and modulus,
respectively.
The Iml-bit
output
G(1 ml, q) of G
with

seed q, where

the second part
where

f

Im I is the bit length

mz. The third

is a message

concatenation.

part

digest

(See Section

of m, is exclusive-ored

m~ is computed

function

(of

a certain

4.1 for a description

with

form),

of message

and

Routine

by checking

that

routines

deliver’

II denotes

digests.)

the assumption
that
inverting
RSA encryption
or f is not
recipient
of ( ml, mg, ma) can verify
that this ciphertext
was
structed
from a plaintext
and Lee 1994].
Then the request’
and

m to form

as m~ = q ~(mlll~zj mod N,
Under

possible,
properly

( m~)e - (ml )~(~lllm z) mod N
execute

the
con[Lim

as follows.

request’(m):

(1) Generate
Lee [1994],

where

“o”

(2) Execute
Routine

a new, random
i.e.,

denotes

bitwise

request((ml,
deliver’(m)

seed q, O < q < N, and encrypt

m as in Lim

and

exclusive-or.

m2, m~)).
at server

(1) If m is not of the form

(ml,

s,:
m2, m~ ), then

(2) If (m~)e # (ml)f(~ll~2)
mod N, then return
this may be a chosen-ciphertext
attack).

return

to the

to the calling

calling
routine

(3) If this is the hth execution
of deliver’,
then execute
bcast((
where cz~l,l - (ml)~z mod N is S,’S partial
result for ml.

routine.
(because
h, anl,,

)),

(4) Wait until a set of messages {( SJ, ( h, a~))}J. ~, IT I = k, has been received
such that
A~l,~
= ml . ~j.
of
T( a~ )PJ, T mod N is the correct decryption
ml (i.e., such that (A~l,~)’
- ml mod N).
(5) Execute
only

after

deliuer(G(lm21,

A~l,T

) o m2 ) and

return

to the

calling

routine

it has completed.
ACM

Transactions

on Programming

Languages

and Systems,

Vol. 16, No. 3, May 1994

1004

M. K, Relter and K, P, Birman

.

THEOREM

3.

This

protocol

satisfies

Delivery

Validity

with

request

replaced

by request’.
PROOF.

correct

Suppose

(i – l)th
Thus,

server,

execution

deliver’,

deliver’(m)

all correct

and

is the

m,)

suppose that
By Delivery

ith

or broadcast

the latter

case at least

their

partial

k correct

results

partial

of

completes

all correct
routine
in step

at all correct
servers,
ensuring
a request
and return
to the calling

n > t + b, in

client

c executes

at all correct
any k partial
be decrypted,
THEOREM
PROOF.
is the

servers,
results
m will
4.

By

ith

This

deliver’(

( ml,

m2,

m ~))

that if a

is executed

where ( m ~, m2, m3 ) is as created in request’(m).
for ml from k correct and honest servers enables
be delivered.
❑
protocol

Delivery

execution

then

request’(m),

by and

that each correct
server will
routine.
Thus, by induction
it

at correct servers completes.
follows that each execution
of deliver’
replaced
with deliver’
then implies
Delivery
Validity
with deliver
correct

satisfies

Order

with

of deliver’

the ith execution
of deliver’
honest server executes deliver(m)
Then, the ith execution
of deliver’

is

Delivery

Since
m ~ to

Order.

replaced

deliver

at a correct

by

servers.
1 or 2 of

are broadcast

ml

a

its

replaced

deliz~er
at

for

at

deliver’

server

in step 3. Because

results

received

deliver

execution

each correct
Order with

of deliver’.
is the ith execution
of deliver’
servers either return
to the calling

deliver’(m)

thus

deliuer’(

that

or honest

if deliver’(m)

by deliver’,

or honest

server,

then

deliver’(m)

at all correct
servers.
Suppose a correct
or
for some m in its ith execution
of deliver’.
must

be of the

form

deliver’(

( m ~, rnz,

m~ )).

Consider
this execution
of deliver’((
ml, m2, m3 )) at a different
correct
or
such that
honest
server
s’. Because
there is only one seed q, O < q < ~,
deliver(
m’ ) for some
q’
= m ~ mod N,
it is not possible
for s’ to execute
m’ # m. If s’ is correct,
then eventually
k partial
results
from k correct and
honest
servers
will be received
at s’, which
will enable
it to decrypt
and
deliver

m. Ifs’

is honest

does not complete
THEOREM
satisfies

If

5.

and does not deliver

and

s’ never

the

threshold

again

executes

cryptosystem

then deliver’

m,

deliver’
is

secure,

((ml,

(or deliver).
then

this

m~,

m ~ ))

❑
protocol

Causality.

If c
that
a corrector
honest
client
c executes
request’(m).
request((
ml, m2, m3 )),
for sufficiently
long, then c executes
in reqztest’( m). If the threshold
where
ml,
mz, and m3 are as created
point
at which
m
could
be decrypted
cryptosystem
is secure, then the earliest
anywhere
is sometime
after
some correct
or honest
server
broadcasts
its
PROOF.

makes

Suppose

progress

ml, m ~, m~ )). If no correct
or honest server
partial
result for ml, in deliver’((
is trivially
satisfied.
ever broadcasts
its partial
result for m ~, then Causality
Otherwise,
let s be the first correct or honest server to broadcast
its partial
result for m ~.
deliuer(
m’ ) for some
m’ # m is executed
at a correct
or
Suppose
that
deliver(m)
has not yet been executed
at s’. Then,
honest
server
s’ when
deliver(
m’ ) must be executed
at s’ when deliver’((
ml, m ~, m ~ )) has not been
ACM

TransactIons

on Programmmg

Languages

and Systems,

Vol

16, No

3, May

1994

How to Securely Replicate Services
executed

at

s’, because

deliver’((

ml,

mz, m~ )) prior

at s before

deliuer’((

broadcasts
(and

5.3

ml,

its partial

thus

otherwise

for ml

before

would

have

So, deliver

mz, m~ )). Because

result

was issued)

deliver(m)

to deliver.

ml

cannot

in deiiuer’((

m is decrypted

ml,

.

1005

been

executed

must

be executed

be decrypted

in

before

s

ma, m~ )), m’ is delivered

❑

anywhere.

Discussion

In a failure-free
additional

run,

when this protocol
Section 4.2 is used
cast,

two

results,

sets
and

clients

the

of

responses

called

causal

causal

denial

of requests
prevent
guarantee
should

discussion

protocol,

That

to satisfy

servers.

the

in the sense of Reiter
suffice

Reiter

for virtually

to prevent

causal
protocol

by the

higher

due

relation-

[ 1993].

protocol

another

In the

of Section

class of attacks

article,

preventing

requirements

on the

of Section

5.2 does not

we believe

that

all applications.
for a more

them

at the
of Section

causal

and Gong

of this

and Gong,

and Gong [1993]

and measures

of detecting

in Reiter

context

the

While

are slightly

also presents

the

partial

requirements

attacks.

addressed

work
in

to disseminate

however,

in an
Thus,

and the protocol
of
in one atomic broad-

as in the protocol

importance

attack

although

is sufficient
to the

the

results

concurrently.

storage

chosen-ciphertext

can be found

denial.

forgery,

should

deliver’

beast

The

are the same

of the

there,

causal

consult

attacks

protocol

environments

denial

with
executed

of

client.

costs in this

presented

5.2 is termed

are

executions

for preventing

general

framework

which

to the

in this

4.2. The computation

in hostile

of deliuer

beast,

n. concurrent

the

and servers

A more

of

is used to deliver
client
requests,
to sign responses,
a request
results

to the mechanisms
ships

replacement

n executions

delivery

The interested

detailed

fully

the Causality
reader

description

of these

in some situations.

6. CONCLUSION
We have
cation

presented

of the

a method

state

replicated

as n servers,

computed

by correct

also addressed
We illustrated

approach.

where
servers

and

will

of maintaining

a security

breach

in

the

sequence

presented

an approach

replicating

With

our

n > t + b, so that

the issue

causality
methods
servers.

for securely

machine

not

resulting

of requests

to counter

this

is that they free the client
This is achieved
by employing

from

a modifi-

clients

accept

other
order

will

responses.
among

client

an intruder’s

processed
problem.

using
a service

accept

a causal

services

technique,

by

ability

the

can be

responses
We have
requests.
to violate

service,

An important

feature

and

we

of our

of the responsibility
of authenticating
two recent advances in cryptography,

namely,
threshold
cryptosystems
and threshold
signature
schemes. We have
implemented
a prototype
authentication
service using one of our protocols,
and preliminary
implementations
for modular

data indicate
if the servers

that our techniques
can yield efficient
service
are equipped
with high-performance
hardware

exponentiation.
ACM

Transactions

on Programming

Languages

and Systems,

Vol

16, No 3. May 1994

6.1

M. K. Reiter and K. P. Birman

.

1006

Future

6.1.1

Work

Atomic

limiting

the

Broadcast.

general

At the

usefulness

present

of our

time,

one of the

techniques,

and

chine replication,
is that
they rely on an atomic
Section
3). It is well known
that
it is impossible

primary

indeed

factors

of state

ma-

broadcast
protocol
(see
to find a deterministic

solution
to consensus, and thus atomic broadcast,
in distributed
systems that
can suffer even a single crash failure
[Fischer
et al. 1985]. We believe that an
important
this

direction

for future

impossibility

One

result

approach

to circumventing

sider

only

sage

transmission

atomic

synchronous

been

and

protocols

devised

is to find

for

impossibility

in which

ways

suffice

result

there

execution

that

practical

to circumvent

model.

this

systems,

times

broadcast

already

research

in our system

speeds

bounds

of processes.

for various

synchronous

has been

are known

Deterministic

definitions

systems

(e.g.,

to conon mes-

of honest

Cristian

have

et al. [1985],

Gopal et al. [19901, and Schneider
[1990])
and have been implemented
in
some efforts
(e.g., Shrivastava
et al. [1992]).
With
such a protocol,
only
the subsystem
of servers must be synchronous,
because an atomic broadcast
protocol

for

client

protocol

for

the

requests

on

requests
servers

behalf

by

of clients.

synchronous
maintain.

system

A second

approach

employ

can be implemented
alone

is

having

One

that

such

systems

techniques.

can

be

broadcast

that

difficult

of Fischer

there

broadcast

atomically

of protocols

the result
While

an atomic

servers

drawback

to circumventing

randomization

using

the

are several

rely

to

on

build

a

and

et al. [1985]

is to

randomized

solu-

tions
to the consensus
problem
Dwork
[1989]),
there
has been

in asynchronous
systems
(see Chor and
much less research
on randomized
atomic

broadcast
described

communication
any solution

atomic
protocols

protocols.
a method
broadcast,
for

Unfortunately,
general use.
Many
real

In a private
to transform
which

automatically

asynchronous

systems

the protocols
systems

yields
from

produced

circumvent

randomized

randomized

by this
the

in May, 1992, T. D. Chandra
to consensus
into a solution
to

translation

impossibility

atomic

broadcast

consensus

protocols.

are impractical
of

deterministic,

for
asy-

nchronous atomic broadcast
in more benign
failure
models by employing
an
membership
protocol
(e.g., Ricciardi
[1992]). A membership
protoappropriate
col is used to remove
a process from participation
in the atomic broadcast
protocol
if it appears
to be faulty.
While this risks the exclusion
of a correct
process from
the broadcast
protocol,
it eliminates
the factor
that
makes
atomic
broadcast
impossible
in asynchronous
systems,
namely,
that
is is
impossible
to determine
whether
a process has actually
failed or is only very
slow. We have designed
and are presently
implementing
a membership
protocol

for use in our system

atomic broadcast
that
Finally,
we should

model

is sufficient
note that

that

enables

atomic
broadcast
is not necessary.
For instance,
authentication
service discussed in Section 4.4.
ACM

TransactIons

on Programming

us to achieve

a variation

for our purposes
[Reiter
1994].
for services
for which
requests

Languages

and Systems,

Vol

this

16, No

was

3, May

the

of

commute,
case for

1994.

the

How to Securely Rephcate Services
6.1.2
ond

Verifiable

direction

signature
Yair

future

schemes

Frankel.

verifiable
servers

Threshold

for

In addition

to detect

whether

knowledge,

which

secret

results

sharing

in Sections
servers

such

of such

to us by

4.1 and 5.1, a

would

other

schemes

no implementation

threshold

suggested

cryptosystem
from

A sec-

verifiable

were initially

or

1007

Cryptosystems.
of

discussed

scheme

partial

and

development

to the properties

signature

(cf., verifiable

To our

Schemes

is the

and cryptosystems,

threshold

correctly

Signature
work

.

enable
were

as in Feldman

a signature

the

created
[1987]).

scheme

or cryp-

tosystem
has been proposed.
However,
in principle
this detection
capability
could enable us to eliminate
the (worst-case)
exponential
growth
as a function
of b of the time

to search

or sign a response
schemes
cols.

and cryptosystems

6.2

Related

This

work

was largely

allows

principals

two

n > t + 6. The

ately

be applied

requirements.
our

other

efficiency

which

signature
of our proto-

presents

in

service

shared

in the

present

Section

work

4.4,

our

requires

each

there

key

provided

cannot

immedi-

of the additional

authentication

of Gong

a replicated,

described

encryption

because

public-key

scheme

approach

authentication
authors

using

data

repositories

however,

focused

both

secrecy

method

has

service.
client

data

a file

to reconstruct

defend

against

F into

been

Moreover,

to authenticate

modification

integrity

pieces,

[1989],

each

of size

scheme

of these

data

was

of arbi[1978a].

of data.

in Herlihy

and secrecy

expected

to make

tolerant

in Lamport

replication

was discussed

In Rabin

F. This

services

considered

on secure

are again

was developed

suffice

first

methods

clients

individually.

algorithm

to construct

was

have

quorum

for the case in which
schemes,

decomposes

discussed

machine

with

these

dispersal

the

[1989],

a secret,

as discussed

the

state

replication

[1988]

in deliuer’

individually.

the

then,

a request
of verifiable

The authentication

such a service,

an analogous

scheme,

failures

Since

method

However,

each server

data

decrypt

to improve

by Gong

service.

to construct

to construct

Using

that

the development

help

to establish

that

trary

may

inspired

authentication

unlike

results

Thus,

Work

shared-key

used

for partial

in respond’.

Secure

and Tygar

are important.

In

to be able to authenticate

a space-efhcient

information

highly

The scheme

lF1/1,

extended

available.
such

that

any

in Krawczyk

1 pieces
[1993]

to

pieces.

ACKNOWLEDGMENTS

This
Blaze

work

benefited

(AT & T Bell

from

discussions

Laboratories),

with

Tushar

and information
Chandra

(Cornell

Frankel
(GTE Laboratories),
Li Gong (SRI International),
Bell Laboratories),
Tom London
(AT & T Bell Laboratories),
(AT & T Bell Laboratories),
and Sam
gratefully
acknowledge
the suggestions
ACM

Transactions

on Programming

provided

and Systems,

Yair

Jack Lacy (AT&T
Andrew
Odlyzko

Toueg (Cornell
University).
of the anonymous
referees.
Languages

by Matt

University),

We

also

Vol. 16, No. 3, May 1994.

1008

M. K. Reiter

.

and

K. P. Birman

REFERENCES
BIRMAN,

K. P., SCHIPER, A., AND STEPHENSON,

P.

1991.

Lightweight

causal

and

atomic

group

272–314.
in Cryptology
BRICKELL, E. 1990. A survey of hardware implementations
of RSA. In Advances
—CRYPTO
’89 Proceedings.
Lecture Notes in Computer Science, vol. 435. Springer-Verlag,
New York, 368-370.
Res. 5,
1989. Randomization
in Byzantine agreement. Adu. Comput
CHOR, B., AND DV?OFW,C
multlcast.

ACM

Trans.

Comput.

9, 3 (Aug.),

Syst.

443-497.
CRISTIAN,

F.,

message

AGHILI,

H.,

diffusion

STRONG, R., AND DOLEV,

to Byzantine

agreement.

In

D.

1985.

Atomic

Proceedings

of the

broadcast:
15th

From

InternatLona

simple
1 Sympo-

on Fault-Tolerant
Computing.
200–206.
A revised version appears as IBM Res. Lab.
Tech, Rep. RJ5244 (April 1989), IBM, Armonk, N.Y.
DENNING, D. E. 1984. Digital signatures with RSA and other public-key cryptosystems. Com mun. ACM 27, 4 (Apr.), 388–392.
DESMEDT Y., AND FRANKEL, Y. 1992
Shared generation of authenticators
and signatures. In
Aduances
m Cryptology
—CRYPTO
’91 Proceedings,
Lecture Notes in Computer Science, vol.
576 Springer-Verlag,
New York, 457-469.
Aduazzces
zn
DE SMEDT, Y., AND FRANKEL, Y.
1990.
Threshold
cryptosystems.
In
Cr.yptology—CRYPTO
’89 Proceedings.
Lecture
Notes in Computer
Science, vol. 435.
Springer-Verlag,
New York, 307-315.
of the
DOLEV, D., DWOR~, C., AND NAOR, M.
1991. Non-malleable
cryptography.
In Proceedings
23rd Annual
ACM Symposium
on Theory of Computmg.
ACM, New York, 542-552.
and a signature
scheme based on discrete
ELGAMAL, T. 1985. A public key cryptosystem
IEEE
Trans.
Inf. Theory.
IT-31,
4 (July), 469-472.
logarithms.
FELDMAN, P. 1987. A practical scheme for non-interactive
verifiable
secret sharing. In Proceedings
of the 28th Annual
Symposium
on Foundations
of Computer
Science.
IEEE, New
York, 427-437.
Impossibility
of distributed
consenFISCHER, M. J., LYNCH, N. A., AND PATERSON, M. S. 1985.
sus with one faulty
process. J. ACM 32, 2 (Apr.), 374–382.
FRANKEL, Y., AND DESMEDT, Y. 1992. Distributed
reliable threshold multislgnature.
Tech. Rep.
TR-92-04-02, Dept. of EE & CS, Univ. of Wisconsin at Milwaukee
GONG, L. 1989. Securely replicating
authentication
services In 1%-oceedmgs of the 9th Internaswm

tional

Conference

on DwtrZbuted

Computmg

Systems.

GOPAL, A., STRONG, R., TOUEG, S., AND CRISTL+N, F.
Proceedings

of the 9th Annual

ACM

New York, 297-309.
HERLIHY, M. P,, AND TSGAR, J, D.
Cryptology

—C’RYPTO

Sprmger-Verlag,

’87

New

JOSEPH, M. K.

1987.

Symposium

1988.

York,

379-391.
the

Early-delivery

on Prlnclples

Lecture

elimination

Notes

of the

atomic

of Dwtnbuted

How to make replicated

Proceedings.

Towards

85–91.

1990.

in

effects

broadcast.

In

ACM,

Computmg.

data secure, In Aduances
Computer

Science,

of malicious

logzc: Fault

vol

m
293.

tolerance

of the 10th NBSINCSC
Na t~ona 1 Computer Security Conference.
NBS/NCSC,
Washington,
DC., 238-244.
KrwwrzyK, H.
1993. Distributed
fingerprints
and secure information
dispersal. In Proceedings
of the 12th Annual
ACM Symposium
on Principles
of Distributed
Computing.
ACM, New York,
207-218.
of
LAIH, C. S. AND HARN, L. 1991, Generalized
threshold cryptosystems
In Pre-Proceedings
approaches.

In

Proceedings

ASIACRYPT

’91.

LAMPORT,L.

1978a.

Netw.

LAMPORT, L.
ACM

1978b.

21, 7 (July),

LAMPSON,

Theory

H.,

Time,
M.,

Notes

in Computer

and the ordering

BURROWS, M.,

AND LEE, P, J.

ciphertext

Transactions

clocks,

and practice.

chosen

ACM

of rehable

distributed

multiprocess

systems. Comput.

of events

in a distributed

system.

Commun.

558-565,

B., ABADI,

systems:

LIM, C.

The implementation

2, 95–114.

attacks,
Science,

ACM

1994.
In

AND WOBBER,
Trans.

Compzst,

Another

Advances

method
zn

E.
for

Cryptology

vol. 773. Springer-Verlag,

on Programmmg

Languages

1992,

Syst.

and Systems,

Authentlcatlon

10, 4 (Nov.),

attaining

security

—CRYPTO

New

York,

in

’93

against
Proceedings.

420-434.

VOI 16, No

distributed

265–310.

3, May

1994

adaptively
Lecture

How to Securely Replicate Services
ORUP,

B.,

SVENDSEN,

implementation.
Computer
RABIN,

M.

tolerance.

E.,

In

Sciencej
O.

REIT~R,M. K.
Symposium

E.

in Cryptology

Efficient

dispersal

1991.

VICTOR:

—EUROCRYPT

vol. 473, Springer-Verlag,

1989.
J. ACM

AND ANDREASEN,

Advances

New

York,

of information

An

efficient

’90 Proceedings.

1009

.
RSA

hardware

Lecture

Notes

in

245-252.
for

security,

load

balancing,

and

fault

(Apr.), 335-348.

36, 2

1994. A secure group membership
on Research

in Securcty

protocol. In Proceedings
of the 1994 IEEE
IEEE, New York. To be published.
for fault-tolerant
systems. Ph.D. thesis, Cornell

and

Priuacy.

REITER, M. K.
1993. A security architecture
Univ., Ithaca, N.Y.
REITER, M. K., AND GONG, L. 1993. Preventing
denial and forgery of causal relationships
in
of the 1993
IEEE
Symposium
on Research
in Security
and
distributed
systems. In Proceedings
Prwacy.
IEEE, New York, 30-40.
REITER, M. K., BIRMAN, K. P.j AND GONG, L. 1992. Integrating
security in a group oriented
of the 19921EEE
Symposium
on Research
m Security
and
distributed
system. In Proceedings
Priuacy. IEEE, New Yorkj 18-32.
RICCIARDI, A.M.
1992. The~oup
membership problem inasynchronous
systems. Ph. D. thesis,
Cornell Univ., Ithaca, N.Y.
RIVEST, R.L.
1991. The MD4message
digest algorithm. In Aduar~ces in Cryptology -CRYPTO
Lecture Notes in Computer Science, vol. 537. Springer-Verlag,
New York,
’90 Proceedings.
303-311.
RIVEST, R. L., SHAMIR, A., AND ADLEMAN, L. 1978. A method for obtaining
digital signatures
ACM21,
2 (Feb.), 120–126.
andpublic-key
cryptosystems. Commun.
SCHNEIDER, F. B. 1990. Implementing
fault-tolerant
services using the state machine apACM Comput.
Suru.22,
4( Dec.), 299-319.
preach: A tutorial.
in Cryptology
: Proceedings
of
SEDLAK, H.
1988. The RSAcryptography
processor. In Advances
EUROCRYPT

’87. Lecture

Notes

in Computer

Science,

vol.

304.

Springer-Verlag,

New

York,

95-105.
SHAND, M., ANIIVUILLEMIN,
ings

of the llth

IEEE

J.

1993.

Fast

implementations

of RSAcryptography.

In

Proceed-

IEEE, New York.
P. D., SP~IRS, N. A., TAO, S.jmDTULLY,
A. 1992. Principal
ofreliable
node architectures
for distributed
systems. IEEE

Symposium

on Computer

Arithn~etic.

SHRIVASTAVA,S. K., EZHILCHELV~,
features of the VOLTANfamily
Trans. Comput.
41, 5 (May), 542-549.

STEINER, J. G., NEU MAN, C., AND SCHILLER,
open

network

systems.

tion, 191-202.
TURN, R., AND HABIBI, J.
ings

In

Proceedings

1986.

of the 9th NBS\NCSC

Comput.

Surv,

ACM

Computer

1983.

15, 2 (June),

Received June 1992; revised

1988.

Security

Winter

ofsecurity
Security

An authentication
Conference.

and fault-tolerance.
NBS/NCSC,

Conference.

mechanisms

in high-level

service

for

USE NIX Associain ProceedWashington

network

protocols.

135-171.

May 1993; accepted July

Transactions

Kerberos:

USENIX

Ontheinteractions

National

D. C., 138-142.
VOYDOCK, V. L., AND KRNT, S. T.
ACM

J. I.
of the

on Programming

1993

Languages

and Systems,

Vol

16, No. 3, May 1994

